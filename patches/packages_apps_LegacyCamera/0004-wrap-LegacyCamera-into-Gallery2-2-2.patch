From bd50babc9155f96a82840367c3829543a4afbc19 Mon Sep 17 00:00:00 2001
From: Bryan Gantt <dragonzkiller@gmail.com>
Date: Sat, 29 Sep 2012 23:35:20 -0500
Subject: [PATCH 1/2] wrap LegacyCamera into Gallery2 (2/2)

-remove LegacyCamera makefiles
-move panorama to com.android.camera
-change preference xmls to match with gallery package name

Change-Id: I107d8820975c2259e26f003420149106d4ebcf57
---
 Android.mk                                         |   22 -
 AndroidManifest.xml                                |   77 --
 CleanSpec.mk                                       |   52 -
 jni/feature_mos_jni.cpp                            |   22 +-
 jni/mosaic_renderer_jni.cpp                        |   28 +-
 proguard.flags                                     |   19 -
 res/layout-sw600dp/pano_capture.xml                |    4 +-
 res/layout-sw600dp/pano_review.xml                 |    2 +-
 res/layout/pano_capture.xml                        |    4 +-
 res/layout/pano_review.xml                         |    2 +-
 res/xml/camera_preferences.xml                     |    2 +-
 res/xml/video_preferences.xml                      |    2 +-
 src/com/android/camera/MenuHelper.java             |    2 +-
 src/com/android/camera/Mosaic.java                 |  206 ++++
 src/com/android/camera/MosaicFrameProcessor.java   |  237 ++++
 src/com/android/camera/MosaicRenderer.java         |   89 ++
 .../android/camera/MosaicRendererSurfaceView.java  |  374 +++++++
 .../camera/MosaicRendererSurfaceViewRenderer.java  |   83 ++
 src/com/android/camera/PanoProgressBar.java        |  185 ++++
 src/com/android/camera/PanoUtil.java               |   86 ++
 src/com/android/camera/PanoramaActivity.java       | 1170 ++++++++++++++++++++
 src/com/android/camera/panorama/Mosaic.java        |  206 ----
 .../camera/panorama/MosaicFrameProcessor.java      |  237 ----
 .../android/camera/panorama/MosaicRenderer.java    |   89 --
 .../camera/panorama/MosaicRendererSurfaceView.java |  374 -------
 .../MosaicRendererSurfaceViewRenderer.java         |   83 --
 .../android/camera/panorama/PanoProgressBar.java   |  185 ----
 src/com/android/camera/panorama/PanoUtil.java      |   86 --
 .../android/camera/panorama/PanoramaActivity.java  | 1170 --------------------
 29 files changed, 2464 insertions(+), 2634 deletions(-)
 delete mode 100644 Android.mk
 delete mode 100644 AndroidManifest.xml
 delete mode 100644 CleanSpec.mk
 delete mode 100644 proguard.flags
 create mode 100644 src/com/android/camera/Mosaic.java
 create mode 100644 src/com/android/camera/MosaicFrameProcessor.java
 create mode 100644 src/com/android/camera/MosaicRenderer.java
 create mode 100644 src/com/android/camera/MosaicRendererSurfaceView.java
 create mode 100755 src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
 create mode 100644 src/com/android/camera/PanoProgressBar.java
 create mode 100644 src/com/android/camera/PanoUtil.java
 create mode 100755 src/com/android/camera/PanoramaActivity.java
 delete mode 100644 src/com/android/camera/panorama/Mosaic.java
 delete mode 100644 src/com/android/camera/panorama/MosaicFrameProcessor.java
 delete mode 100644 src/com/android/camera/panorama/MosaicRenderer.java
 delete mode 100644 src/com/android/camera/panorama/MosaicRendererSurfaceView.java
 delete mode 100755 src/com/android/camera/panorama/MosaicRendererSurfaceViewRenderer.java
 delete mode 100644 src/com/android/camera/panorama/PanoProgressBar.java
 delete mode 100644 src/com/android/camera/panorama/PanoUtil.java
 delete mode 100755 src/com/android/camera/panorama/PanoramaActivity.java

diff --git a/Android.mk b/Android.mk
deleted file mode 100644
index ec46e82..0000000
--- a/Android.mk
+++ /dev/null
@@ -1,22 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_PACKAGE_NAME := LegacyCamera
-#LOCAL_SDK_VERSION := current
-
-LOCAL_JNI_SHARED_LIBRARIES := libjni_legacymosaic
-
-LOCAL_REQUIRED_MODULES := libjni_legacymosaic
-
-LOCAL_PROGUARD_FLAG_FILES := proguard.flags
-
-include $(BUILD_PACKAGE)
-
-ifeq ($(strip $(LOCAL_PACKAGE_OVERRIDES)),)
-# Use the following include to make our test apk.
-include $(call all-makefiles-under, $(LOCAL_PATH))
-endif
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
deleted file mode 100644
index ee57c31..0000000
--- a/AndroidManifest.xml
+++ /dev/null
@@ -1,77 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.camera"
-        android:versionCode="1"
-        android:versionName="1"
-        >
-
-    <original-package android:name="com.android.camera" />
-
-    <uses-permission android:name="android.permission.CAMERA" />
-    <uses-feature android:name="android.hardware.camera" />
-    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />
-
-    <uses-permission android:name="android.permission.RECORD_AUDIO" />
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
-    <uses-permission android:name="android.permission.WAKE_LOCK" />
-    <uses-permission android:name="android.permission.SET_WALLPAPER" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.READ_SMS" />
-
-    <application android:icon="@mipmap/ic_launcher_camera"
-            android:name="com.android.camera.CameraAppImpl"
-            android:label="@string/camera_label"
-            android:theme="@style/ThemeCamera"
-            android:hardwareAccelerated="true">
-        <uses-library android:name="com.google.android.media.effects" android:required="false" />
-        <receiver android:name="com.android.camera.CameraButtonIntentReceiver">
-            <intent-filter>
-                <action android:name="android.intent.action.CAMERA_BUTTON"/>
-            </intent-filter>
-        </receiver>
-        <activity android:name="com.android.camera.Camera"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.IMAGE_CAPTURE" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.STILL_IMAGE_CAMERA" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <activity android:name="com.android.camera.VideoCamera"
-                android:label="@string/video_camera_label"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:icon="@mipmap/ic_launcher_video_camera"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan">
-            <intent-filter>
-                <action android:name="android.media.action.VIDEO_CAMERA" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.VIDEO_CAPTURE" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <!-- Suppose users enter panorama from launcher, turn off the screen,
-             turn on the screen, and enter the camera from the lock screen.
-             They can switch to panorama from there. Use singleTask so there
-             will be only one panorama activity. -->
-        <activity android:name="com.android.camera.panorama.PanoramaActivity"
-                android:label="@string/pano_dialog_title"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan"
-                android:launchMode="singleTask">
-        </activity>
-    </application>
-</manifest>
-
diff --git a/CleanSpec.mk b/CleanSpec.mk
deleted file mode 100644
index 1cf8763..0000000
--- a/CleanSpec.mk
+++ /dev/null
@@ -1,52 +0,0 @@
-# Copyright (C) 2007 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# If you don't need to do a full clean build but would like to touch
-# a file or delete some intermediate files, add a clean step to the end
-# of the list.  These steps will only be run once, if they haven't been
-# run before.
-#
-# E.g.:
-#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)
-#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)
-#
-# Always use "touch -c" and "rm -f" or "rm -rf" to gracefully deal with
-# files that are missing or have been moved.
-#
-# Use $(PRODUCT_OUT) to get to the "out/target/product/blah/" directory.
-# Use $(OUT_DIR) to refer to the "out" directory.
-#
-# If you need to re-do something that's already mentioned, just copy
-# the command and add it to the bottom of the list.  E.g., if a change
-# that you made last week required touching a file and a change you
-# made today requires touching the same file, just copy the old
-# touch step and add it to the end of the list.
-#
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
-
-# For example:
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)
-#$(call add-clean-step, find $(OUT_DIR) -type f -name "IGTalkSession*" -print0 | xargs -0 rm -f)
-#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)
-$(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/APPS/Camera*)
-$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/Camera*)
-$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/Camera*)
-
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
diff --git a/jni/feature_mos_jni.cpp b/jni/feature_mos_jni.cpp
index 4c08257..8ec21d4 100644
--- a/jni/feature_mos_jni.cpp
+++ b/jni/feature_mos_jni.cpp
@@ -274,7 +274,7 @@ void YUV420toYVU24_NEW(ImageType yvu24, ImageType yuv420sp, int width,
 }
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_allocateMosaicMemory(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_allocateMosaicMemory(
         JNIEnv* env, jobject thiz, jint width, jint height)
 {
     tWidth[HR] = width;
@@ -293,7 +293,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_allocateMosaicMem
     AllocateTextureMemory(tWidth[HR], tHeight[HR], tWidth[LR], tHeight[LR]);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_freeMosaicMemory(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_freeMosaicMemory(
         JNIEnv* env, jobject thiz)
 {
     for(int i = 0; i < MAX_FRAMES; i++)
@@ -383,7 +383,7 @@ void ConvertYVUAiToPlanarYVU(unsigned char *planar, unsigned char *in, int width
     }
 }
 
-JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceImageFromGPU(
+JNIEXPORT jfloatArray JNICALL Java_com_android_camera_Mosaic_setSourceImageFromGPU(
         JNIEnv* env, jobject thiz)
 {
     double  t0, t1, time_c;
@@ -435,7 +435,7 @@ JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceI
 
 
 
-JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceImage(
+JNIEXPORT jfloatArray JNICALL Java_com_android_camera_Mosaic_setSourceImage(
         JNIEnv* env, jobject thiz, jbyteArray photo_data)
 {
     double  t0, t1, time_c;
@@ -492,19 +492,19 @@ JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceI
     return bytes;
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_setBlendingType(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_setBlendingType(
         JNIEnv* env, jobject thiz, jint type)
 {
     blendingType = int(type);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_setStripType(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_setStripType(
         JNIEnv* env, jobject thiz, jint type)
 {
     stripType = int(type);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_reset(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_reset(
         JNIEnv* env, jobject thiz)
 {
     frame_number_HR = 0;
@@ -519,7 +519,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_reset(
     Init(LR,MAX_FRAMES);
 }
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_reportProgress(
+JNIEXPORT jint JNICALL Java_com_android_camera_Mosaic_reportProgress(
         JNIEnv* env, jobject thiz, jboolean hires, jboolean cancel_computation)
 {
     if(bool(hires))
@@ -533,7 +533,7 @@ JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_reportProgress(
         return (jint) gProgress[LR];
 }
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_createMosaic(
+JNIEXPORT jint JNICALL Java_com_android_camera_Mosaic_createMosaic(
         JNIEnv* env, jobject thiz, jboolean value)
 {
     high_res = bool(value);
@@ -590,7 +590,7 @@ JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_createMosaic(
     return (jint) ret;
 }
 
-JNIEXPORT jintArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosaic(
+JNIEXPORT jintArray JNICALL Java_com_android_camera_Mosaic_getFinalMosaic(
         JNIEnv* env, jobject thiz)
 {
     int y,x;
@@ -635,7 +635,7 @@ JNIEXPORT jintArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosa
     return bytes;
 }
 
-JNIEXPORT jbyteArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosaicNV21(
+JNIEXPORT jbyteArray JNICALL Java_com_android_camera_Mosaic_getFinalMosaicNV21(
         JNIEnv* env, jobject thiz)
 {
     int y,x;
diff --git a/jni/mosaic_renderer_jni.cpp b/jni/mosaic_renderer_jni.cpp
index af1cc07..6f449ad 100644
--- a/jni/mosaic_renderer_jni.cpp
+++ b/jni/mosaic_renderer_jni.cpp
@@ -463,24 +463,24 @@ void FreeTextureMemory()
 
 extern "C"
 {
-    JNIEXPORT jint JNICALL Java_com_android_camera_panorama_MosaicRenderer_init(
+    JNIEXPORT jint JNICALL Java_com_android_camera_MosaicRenderer_init(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_reset(
             JNIEnv * env, jobject obj,  jint width, jint height,
             jboolean isLandscapeOrientation);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_preprocess(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_preprocess(
             JNIEnv * env, jobject obj, jfloatArray stMatrix);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferGPUtoCPU(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_transferGPUtoCPU(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_step(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_ready(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_ready(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarping(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_setWarping(
             JNIEnv * env, jobject obj, jboolean flag);
 };
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_MosaicRenderer_init(
+JNIEXPORT jint JNICALL Java_com_android_camera_MosaicRenderer_init(
         JNIEnv * env, jobject obj)
 {
     gSurfTexRenderer[LR].InitializeGLProgram();
@@ -544,7 +544,7 @@ void calculateUILayoutScaling(int width, int height, bool isLandscape) {
     }
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_reset(
         JNIEnv * env, jobject obj,  jint width, jint height, jboolean isLandscapeOrientation)
 {
     gIsLandscapeOrientation = isLandscapeOrientation;
@@ -626,7 +626,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
     gPreview.SetInputTextureType(GL_TEXTURE_2D);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_preprocess(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_preprocess(
         JNIEnv * env, jobject obj, jfloatArray stMatrix)
 {
     jfloat *stmat = env->GetFloatArrayElements(stMatrix, 0);
@@ -656,7 +656,7 @@ now_ms(void)
 
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferGPUtoCPU(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_transferGPUtoCPU(
         JNIEnv * env, jobject obj)
 {
     double t0, t1, time_c;
@@ -696,7 +696,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferG
     glBindFramebuffer(GL_FRAMEBUFFER, 0);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_step(
         JNIEnv * env, jobject obj)
 {
     if(!gWarpImage) // ViewFinder
@@ -730,7 +730,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
     }
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarping(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_setWarping(
         JNIEnv * env, jobject obj, jboolean flag)
 {
     // TODO: Review this logic
@@ -757,7 +757,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarpin
 }
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_ready(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_ready(
         JNIEnv * env, jobject obj)
 {
     for(int i=0; i<16; i++)
diff --git a/proguard.flags b/proguard.flags
deleted file mode 100644
index 5bce096..0000000
--- a/proguard.flags
+++ /dev/null
@@ -1,19 +0,0 @@
-# ctors of subclasses of CameraPreference are called with Java reflection.
--keep class * extends com.android.camera.CameraPreference {
-  <init>(...);
-}
-
--keep class com.android.camera.ActivityBase {
-  public int getResultCode();
-  public android.content.Intent getResultData();
-}
-
--keep class com.android.camera.VideoCamera {
-  public boolean isRecording();
-  public void onCancelBgTraining(...);
-  public void onProtectiveCurtainClick(...);
-}
-
--keep class * extends android.app.Activity {
-  @com.android.camera.OnClickAttr <methods>;
-}
diff --git a/res/layout-sw600dp/pano_capture.xml b/res/layout-sw600dp/pano_capture.xml
index 1b2900b..9de0b94 100644
--- a/res/layout-sw600dp/pano_capture.xml
+++ b/res/layout-sw600dp/pano_capture.xml
@@ -58,7 +58,7 @@
                     android:layout_weight="1.67"
                     android:layout_width="match_parent"
                     android:layout_height="0dp">
-                <com.android.camera.panorama.MosaicRendererSurfaceView
+                <com.android.camera.MosaicRendererSurfaceView
                         android:id="@+id/pano_renderer"
                         android:layout_width="match_parent"
                         android:layout_height="match_parent" />
@@ -79,7 +79,7 @@
                         android:layout_width="wrap_content"
                         android:layout_height="wrap_content"
                         android:layout_centerInParent="true">
-                    <com.android.camera.panorama.PanoProgressBar
+                    <com.android.camera.PanoProgressBar
                             android:id="@+id/pano_pan_progress_bar"
                             android:visibility="gone"
                             android:src="@drawable/ic_pan_progression"
diff --git a/res/layout-sw600dp/pano_review.xml b/res/layout-sw600dp/pano_review.xml
index cf1fb54..c8e12a2 100644
--- a/res/layout-sw600dp/pano_review.xml
+++ b/res/layout-sw600dp/pano_review.xml
@@ -70,7 +70,7 @@
                 android:layout_centerInParent="true"
                 android:layout_height="wrap_content"
                 android:layout_width="wrap_content">
-            <com.android.camera.panorama.PanoProgressBar
+            <com.android.camera.PanoProgressBar
                     android:id="@+id/pano_saving_progress_bar"
                     android:src="@drawable/ic_pan_progression"
                     android:layout_centerInParent="true"
diff --git a/res/layout/pano_capture.xml b/res/layout/pano_capture.xml
index 49065fd..8768157 100644
--- a/res/layout/pano_capture.xml
+++ b/res/layout/pano_capture.xml
@@ -39,7 +39,7 @@
                         android:layout_width="wrap_content"
                         android:layout_height="wrap_content"
                         android:layout_centerInParent="true">
-                    <com.android.camera.panorama.PanoProgressBar
+                    <com.android.camera.PanoProgressBar
                             android:id="@+id/pano_pan_progress_bar"
                             android:visibility="gone"
                             android:src="@drawable/ic_pan_progression"
@@ -74,7 +74,7 @@
                     android:layout_weight="1.67"
                     android:layout_width="0dp"
                     android:layout_height="match_parent">
-                <com.android.camera.panorama.MosaicRendererSurfaceView
+                <com.android.camera.MosaicRendererSurfaceView
                         android:id="@+id/pano_renderer"
                         android:layout_width="match_parent"
                         android:layout_height="match_parent" />
diff --git a/res/layout/pano_review.xml b/res/layout/pano_review.xml
index 7b9a92e..5f19e92 100644
--- a/res/layout/pano_review.xml
+++ b/res/layout/pano_review.xml
@@ -41,7 +41,7 @@
                 android:layout_centerInParent="true"
                 android:layout_height="wrap_content"
                 android:layout_width="wrap_content">
-            <com.android.camera.panorama.PanoProgressBar
+            <com.android.camera.PanoProgressBar
                     android:id="@+id/pano_saving_progress_bar"
                     android:src="@drawable/ic_pan_progression"
                     android:layout_centerInParent="true"
diff --git a/res/xml/camera_preferences.xml b/res/xml/camera_preferences.xml
index d9ffcd6..15a62b1 100644
--- a/res/xml/camera_preferences.xml
+++ b/res/xml/camera_preferences.xml
@@ -15,7 +15,7 @@
 -->
 
 <PreferenceGroup
-        xmlns:camera="http://schemas.android.com/apk/res/com.android.camera"
+        xmlns:camera="http://schemas.android.com/apk/res/com.android.gallery3d"
         camera:title="@string/pref_camera_settings_category">
     <IconListPreference
             camera:key="pref_camera_flashmode_key"
diff --git a/res/xml/video_preferences.xml b/res/xml/video_preferences.xml
index e158139..abc5dfe 100644
--- a/res/xml/video_preferences.xml
+++ b/res/xml/video_preferences.xml
@@ -15,7 +15,7 @@
 -->
 
 <PreferenceGroup
-        xmlns:camera="http://schemas.android.com/apk/res/com.android.camera"
+        xmlns:camera="http://schemas.android.com/apk/res/com.android.gallery3d"
         camera:title="@string/pref_camcorder_settings_category">
     <IconListPreference
             camera:key="pref_video_quality_key"
diff --git a/src/com/android/camera/MenuHelper.java b/src/com/android/camera/MenuHelper.java
index 576e9c4..4feade1 100644
--- a/src/com/android/camera/MenuHelper.java
+++ b/src/com/android/camera/MenuHelper.java
@@ -44,7 +44,7 @@ public class MenuHelper {
 
     private static final int NO_ANIMATION = 0;
     private static final String CAMERA_CLASS = "com.android.camera.Camera";
-    private static final String PANORAMA_CLASS = "com.android.camera.panorama.PanoramaActivity";
+    private static final String PANORAMA_CLASS = "com.android.camera.PanoramaActivity";
     private static final String VIDEO_CAMERA_CLASS = "com.android.camera.VideoCamera";
 
     public static void addSwitchModeMenuItem(Menu menu, int mode,
diff --git a/src/com/android/camera/Mosaic.java b/src/com/android/camera/Mosaic.java
new file mode 100644
index 0000000..ce60908
--- /dev/null
+++ b/src/com/android/camera/Mosaic.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+/**
+ * The Java interface to JNI calls regarding mosaic stitching.
+ *
+ * A high-level usage is:
+ *
+ * Mosaic mosaic = new Mosaic();
+ * mosaic.setSourceImageDimensions(width, height);
+ * mosaic.reset(blendType);
+ *
+ * while ((pixels = hasNextImage()) != null) {
+ *    mosaic.setSourceImage(pixels);
+ * }
+ *
+ * mosaic.createMosaic(highRes);
+ * byte[] result = mosaic.getFinalMosaic();
+ *
+ */
+public class Mosaic {
+    /**
+     * In this mode, the images are stitched together in the same spatial arrangement as acquired
+     * i.e. if the user follows a curvy trajectory, the image boundary of the resulting mosaic will
+     * be curved in the same manner. This mode is useful if the user wants to capture a mosaic as
+     * if "painting" the scene using the smart-phone device and does not want any corrective warps
+     * to distort the captured images.
+     */
+    public static final int BLENDTYPE_FULL = 0;
+
+    /**
+     * This mode is the same as BLENDTYPE_FULL except that the resulting mosaic is rotated
+     * to balance the first and last images to be approximately at the same vertical offset in the
+     * output mosaic. This is useful when acquiring a mosaic by a typical panning-like motion to
+     * remove a one-sided curve in the mosaic (typically due to the camera not staying horizontal
+     * during the video capture) and convert it to a more symmetrical "smiley-face" like output.
+     */
+    public static final int BLENDTYPE_PAN = 1;
+
+    /**
+     * This mode compensates for typical "smiley-face" like output in longer mosaics and creates
+     * a rectangular mosaic with minimal black borders (by unwrapping the mosaic onto an imaginary
+     * cylinder). If the user follows a curved trajectory (instead of a perfect panning trajectory),
+     * the resulting mosaic here may suffer from some image distortions in trying to map the
+     * trajectory to a cylinder.
+     */
+    public static final int BLENDTYPE_CYLINDERPAN = 2;
+
+    /**
+     * This mode is basically BLENDTYPE_CYLINDERPAN plus doing a rectangle cropping before returning
+     * the mosaic. The mode is useful for making the resulting mosaic have a rectangle shape.
+     */
+    public static final int BLENDTYPE_HORIZONTAL =3;
+
+    /**
+     * This strip type will use the default thin strips where the strips are
+     * spaced according to the image capture rate.
+     */
+    public static final int STRIPTYPE_THIN = 0;
+
+    /**
+     * This strip type will use wider strips for blending. The strip separation
+     * is controlled by a threshold on the native side. Since the strips are
+     * wider, there is an additional cross-fade blending step to make the seam
+     * boundaries smoother. Since this mode uses lesser image frames, it is
+     * computationally more efficient than the thin strip mode.
+     */
+    public static final int STRIPTYPE_WIDE = 1;
+
+    /**
+     * Return flags returned by createMosaic() are one of the following.
+     */
+    public static final int MOSAIC_RET_OK = 1;
+    public static final int MOSAIC_RET_ERROR = -1;
+    public static final int MOSAIC_RET_CANCELLED = -2;
+    public static final int MOSAIC_RET_LOW_TEXTURE = -3;
+    public static final int MOSAIC_RET_FEW_INLIERS = 2;
+
+
+    static {
+        System.loadLibrary("jni_legacymosaic");
+    }
+
+    /**
+     * Allocate memory for the image frames at the given resolution.
+     *
+     * @param width width of the input frames in pixels
+     * @param height height of the input frames in pixels
+     */
+    public native void allocateMosaicMemory(int width, int height);
+
+    /**
+     * Free memory allocated by allocateMosaicMemory.
+     *
+     */
+    public native void freeMosaicMemory();
+
+    /**
+     * Pass the input image frame to the native layer. Each time the a new
+     * source image t is set, the transformation matrix from the first source
+     * image to t is computed and returned.
+     *
+     * @param pixels source image of NV21 format.
+     * @return Float array of length 11; first 9 entries correspond to the 3x3
+     *         transformation matrix between the first frame and the passed frame;
+     *         the 10th entry is the number of the passed frame, where the counting
+     *         starts from 1; and the 11th entry is the returning code, whose value
+     *         is one of those MOSAIC_RET_* returning flags defined above.
+     */
+    public native float[] setSourceImage(byte[] pixels);
+
+    /**
+     * This is an alternative to the setSourceImage function above. This should
+     * be called when the image data is already on the native side in a fixed
+     * byte array. In implementation, this array is filled by the GL thread
+     * using glReadPixels directly from GPU memory (where it is accessed by
+     * an associated SurfaceTexture).
+     *
+     * @return Float array of length 11; first 9 entries correspond to the 3x3
+     *         transformation matrix between the first frame and the passed frame;
+     *         the 10th entry is the number of the passed frame, where the counting
+     *         starts from 1; and the 11th entry is the returning code, whose value
+     *         is one of those MOSAIC_RET_* returning flags defined above.
+     */
+    public native float[] setSourceImageFromGPU();
+
+    /**
+     * Set the type of blending.
+     *
+     * @param type the blending type defined in the class. {BLENDTYPE_FULL,
+     *        BLENDTYPE_PAN, BLENDTYPE_CYLINDERPAN, BLENDTYPE_HORIZONTAL}
+     */
+    public native void setBlendingType(int type);
+
+    /**
+     * Set the type of strips to use for blending.
+     * @param type the blending strip type to use {STRIPTYPE_THIN,
+     * STRIPTYPE_WIDE}.
+     */
+    public native void setStripType(int type);
+
+    /**
+     * Tell the native layer to create the final mosaic after all the input frame
+     * data have been collected.
+     * The case of generating high-resolution mosaic may take dozens of seconds to finish.
+     *
+     * @param value True means generating a high-resolution mosaic -
+     *        which is based on the original images set in setSourceImage().
+     *        False means generating a low-resolution version -
+     *        which is based on 1/4 downscaled images from the original images.
+     * @return Returns a status code suggesting if the mosaic building was
+     *        successful, in error, or was cancelled by the user.
+     */
+    public native int createMosaic(boolean value);
+
+    /**
+     * Get the data for the created mosaic.
+     *
+     * @return Returns an integer array which contains the final mosaic in the ARGB_8888 format.
+     *         The first MosaicWidth*MosaicHeight values contain the image data, followed by 2
+     *         integers corresponding to the values MosaicWidth and MosaicHeight respectively.
+     */
+    public native int[] getFinalMosaic();
+
+    /**
+     * Get the data for the created mosaic.
+     *
+     * @return Returns a byte array which contains the final mosaic in the NV21 format.
+     *         The first MosaicWidth*MosaicHeight*1.5 values contain the image data, followed by
+     *         8 bytes which pack the MosaicWidth and MosaicHeight integers into 4 bytes each
+     *         respectively.
+     */
+    public native byte[] getFinalMosaicNV21();
+
+    /**
+     * Reset the state of the frame arrays which maintain the captured frame data.
+     * Also re-initializes the native mosaic object to make it ready for capturing a new mosaic.
+     */
+    public native void reset();
+
+    /**
+     * Get the progress status of the mosaic computation process.
+     * @param hires Boolean flag to select whether to report progress of the
+     *              low-res or high-res mosaicer.
+     * @param cancelComputation Boolean flag to allow cancelling the
+     *              mosaic computation when needed from the GUI end.
+     * @return Returns a number from 0-100 where 50 denotes that the mosaic
+     *          computation is 50% done.
+     */
+    public native int reportProgress(boolean hires, boolean cancelComputation);
+}
diff --git a/src/com/android/camera/MosaicFrameProcessor.java b/src/com/android/camera/MosaicFrameProcessor.java
new file mode 100644
index 0000000..5edc8c5
--- /dev/null
+++ b/src/com/android/camera/MosaicFrameProcessor.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.util.Log;
+
+/**
+ * Class to handle the processing of each frame by Mosaicer.
+ */
+public class MosaicFrameProcessor {
+    private static final boolean LOGV = true;
+    private static final String TAG = "MosaicFrameProcessor";
+    private static final int NUM_FRAMES_IN_BUFFER = 2;
+    private static final int MAX_NUMBER_OF_FRAMES = 100;
+    private static final int MOSAIC_RET_CODE_INDEX = 10;
+    private static final int FRAME_COUNT_INDEX = 9;
+    private static final int X_COORD_INDEX = 2;
+    private static final int Y_COORD_INDEX = 5;
+    private static final int HR_TO_LR_DOWNSAMPLE_FACTOR = 4;
+    private static final int WINDOW_SIZE = 3;
+
+    private Mosaic mMosaicer;
+    private boolean mIsMosaicMemoryAllocated = false;
+    private final long [] mFrameTimestamp = new long[NUM_FRAMES_IN_BUFFER];
+    private float mTranslationLastX;
+    private float mTranslationLastY;
+
+    private int mFillIn = 0;
+    private int mTotalFrameCount = 0;
+    private long mLastProcessedFrameTimestamp = 0;
+    private int mLastProcessFrameIdx = -1;
+    private int mCurrProcessFrameIdx = -1;
+
+    // Panning rate is in unit of percentage of image content translation / second.
+    // Use the moving average to calculate the panning rate.
+    private float mPanningRateX;
+    private float mPanningRateY;
+
+    private float[] mDeltaX = new float[WINDOW_SIZE];
+    private float[] mDeltaY = new float[WINDOW_SIZE];
+    private float[] mDeltaTime = new float[WINDOW_SIZE];
+    private int mOldestIdx = 0;
+    private float mTotalTranslationX = 0f;
+    private float mTotalTranslationY = 0f;
+    private float mTotalDeltaTime = 0f;
+
+    private ProgressListener mProgressListener;
+
+    private int mPreviewWidth;
+    private int mPreviewHeight;
+    private int mPreviewBufferSize;
+
+    public interface ProgressListener {
+        public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
+                float progressX, float progressY);
+    }
+
+    public MosaicFrameProcessor(int previewWidth, int previewHeight, int bufSize) {
+        mMosaicer = new Mosaic();
+        mPreviewWidth = previewWidth;
+        mPreviewHeight = previewHeight;
+        mPreviewBufferSize = bufSize;
+    }
+
+    public void setProgressListener(ProgressListener listener) {
+        mProgressListener = listener;
+    }
+
+    public int reportProgress(boolean hires, boolean cancel) {
+        return mMosaicer.reportProgress(hires, cancel);
+    }
+
+    public void initialize() {
+        setupMosaicer(mPreviewWidth, mPreviewHeight, mPreviewBufferSize);
+        setStripType(Mosaic.STRIPTYPE_WIDE);
+        reset();
+    }
+
+    public void clear() {
+        if (mIsMosaicMemoryAllocated) {
+            mIsMosaicMemoryAllocated = false;
+            mMosaicer.freeMosaicMemory();
+        }
+    }
+
+    public void setStripType(int type) {
+        mMosaicer.setStripType(type);
+    }
+
+    private void setupMosaicer(int previewWidth, int previewHeight, int bufSize) {
+        Log.v(TAG, "setupMosaicer w, h=" + previewWidth + ',' + previewHeight + ',' + bufSize);
+        mMosaicer.allocateMosaicMemory(previewWidth, previewHeight);
+        mIsMosaicMemoryAllocated = true;
+
+        mFillIn = 0;
+        if  (mMosaicer != null) {
+            mMosaicer.reset();
+        }
+    }
+
+    public void reset() {
+        // reset() can be called even if MosaicFrameProcessor is not initialized.
+        // Only counters will be changed.
+        mTotalFrameCount = 0;
+        mFillIn = 0;
+        mLastProcessedFrameTimestamp = 0;
+        mTotalTranslationX = 0;
+        mTranslationLastX = 0;
+        mTotalTranslationY = 0;
+        mTranslationLastY = 0;
+        mTotalDeltaTime = 0;
+        mPanningRateX = 0;
+        mPanningRateY = 0;
+        mLastProcessFrameIdx = -1;
+        mCurrProcessFrameIdx = -1;
+        for (int i = 0; i < WINDOW_SIZE; ++i) {
+            mDeltaX[i] = 0f;
+            mDeltaY[i] = 0f;
+            mDeltaTime[i] = 0f;
+        }
+        mMosaicer.reset();
+    }
+
+    public int createMosaic(boolean highRes) {
+        return mMosaicer.createMosaic(highRes);
+    }
+
+    public byte[] getFinalMosaicNV21() {
+        return mMosaicer.getFinalMosaicNV21();
+    }
+
+    // Processes the last filled image frame through the mosaicer and
+    // updates the UI to show progress.
+    // When done, processes and displays the final mosaic.
+    public void processFrame() {
+        if (!mIsMosaicMemoryAllocated) {
+            // clear() is called and buffers are cleared, stop computation.
+            // This can happen when the onPause() is called in the activity, but still some frames
+            // are not processed yet and thus the callback may be invoked.
+            return;
+        }
+        long t1 = System.currentTimeMillis();
+        mFrameTimestamp[mFillIn] = t1;
+
+        mCurrProcessFrameIdx = mFillIn;
+        mFillIn = ((mFillIn + 1) % NUM_FRAMES_IN_BUFFER);
+
+        // Check that we are trying to process a frame different from the
+        // last one processed (useful if this class was running asynchronously)
+        if (mCurrProcessFrameIdx != mLastProcessFrameIdx) {
+            mLastProcessFrameIdx = mCurrProcessFrameIdx;
+
+            // Access the timestamp associated with it...
+            long timestamp = mFrameTimestamp[mCurrProcessFrameIdx];
+
+            // TODO: make the termination condition regarding reaching
+            // MAX_NUMBER_OF_FRAMES solely determined in the library.
+            if (mTotalFrameCount < MAX_NUMBER_OF_FRAMES) {
+                // If we are still collecting new frames for the current mosaic,
+                // process the new frame.
+                calculateTranslationRate(timestamp);
+
+                // Publish progress of the ongoing processing
+                if (mProgressListener != null) {
+                    mProgressListener.onProgress(false, mPanningRateX, mPanningRateY,
+                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
+                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
+                }
+            } else {
+                if (mProgressListener != null) {
+                    mProgressListener.onProgress(true, mPanningRateX, mPanningRateY,
+                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
+                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
+                }
+            }
+        }
+    }
+
+    public void calculateTranslationRate(long now) {
+        float[] frameData = mMosaicer.setSourceImageFromGPU();
+        int ret_code = (int) frameData[MOSAIC_RET_CODE_INDEX];
+        mTotalFrameCount  = (int) frameData[FRAME_COUNT_INDEX];
+        float translationCurrX = frameData[X_COORD_INDEX];
+        float translationCurrY = frameData[Y_COORD_INDEX];
+
+        if (mLastProcessedFrameTimestamp == 0f) {
+            // First time: no need to update delta values.
+            mTranslationLastX = translationCurrX;
+            mTranslationLastY = translationCurrY;
+            mLastProcessedFrameTimestamp = now;
+            return;
+        }
+
+        // Moving average: remove the oldest translation/deltaTime and
+        // add the newest translation/deltaTime in
+        int idx = mOldestIdx;
+        mTotalTranslationX -= mDeltaX[idx];
+        mTotalTranslationY -= mDeltaY[idx];
+        mTotalDeltaTime -= mDeltaTime[idx];
+        mDeltaX[idx] = Math.abs(translationCurrX - mTranslationLastX);
+        mDeltaY[idx] = Math.abs(translationCurrY - mTranslationLastY);
+        mDeltaTime[idx] = (now - mLastProcessedFrameTimestamp) / 1000.0f;
+        mTotalTranslationX += mDeltaX[idx];
+        mTotalTranslationY += mDeltaY[idx];
+        mTotalDeltaTime += mDeltaTime[idx];
+
+        // The panning rate is measured as the rate of the translation percentage in
+        // image width/height. Take the horizontal panning rate for example, the image width
+        // used in finding the translation is (PreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR).
+        // To get the horizontal translation percentage, the horizontal translation,
+        // (translationCurrX - mTranslationLastX), is divided by the
+        // image width. We then get the rate by dividing the translation percentage with deltaTime.
+        mPanningRateX = mTotalTranslationX /
+                (mPreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
+        mPanningRateY = mTotalTranslationY /
+                (mPreviewHeight / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
+
+        mTranslationLastX = translationCurrX;
+        mTranslationLastY = translationCurrY;
+        mLastProcessedFrameTimestamp = now;
+        mOldestIdx = (mOldestIdx + 1) % WINDOW_SIZE;
+    }
+}
diff --git a/src/com/android/camera/MosaicRenderer.java b/src/com/android/camera/MosaicRenderer.java
new file mode 100644
index 0000000..0b13395
--- /dev/null
+++ b/src/com/android/camera/MosaicRenderer.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+/**
+ * The Java interface to JNI calls regarding mosaic preview rendering.
+ *
+ */
+public class MosaicRenderer
+{
+     static
+     {
+         System.loadLibrary("jni_legacymosaic");
+     }
+
+     /**
+      * Function to be called in onSurfaceCreated() to initialize
+      * the GL context, load and link the shaders and create the
+      * program. Returns a texture ID to be used for SurfaceTexture.
+      *
+      * @return textureID the texture ID of the newly generated texture to
+      *          be assigned to the SurfaceTexture object.
+      */
+     public static native int init();
+
+     /**
+      * Pass the drawing surface's width and height to initialize the
+      * renderer viewports and FBO dimensions.
+      *
+      * @param width width of the drawing surface in pixels.
+      * @param height height of the drawing surface in pixels.
+      * @param isLandscapeOrientation is the orientation of the activity layout in landscape.
+      */
+     public static native void reset(int width, int height, boolean isLandscapeOrientation);
+
+     /**
+      * Calling this function will render the SurfaceTexture to a new 2D texture
+      * using the provided STMatrix.
+      *
+      * @param stMatrix texture coordinate transform matrix obtained from the
+      *        Surface texture
+      */
+     public static native void preprocess(float[] stMatrix);
+
+     /**
+      * This function calls glReadPixels to transfer both the low-res and high-res
+      * data from the GPU memory to the CPU memory for further processing by the
+      * mosaicing library.
+      */
+     public static native void transferGPUtoCPU();
+
+     /**
+      * Function to be called in onDrawFrame() to update the screen with
+      * the new frame data.
+      */
+     public static native void step();
+
+     /**
+      * Call this function when a new low-res frame has been processed by
+      * the mosaicing library. This will tell the renderer library to
+      * update its texture and warping transformation. Any calls to step()
+      * after this call will use the new image frame and transformation data.
+      */
+     public static native void ready();
+
+     /**
+      * This function allows toggling between showing the input image data
+      * (without applying any warp) and the warped image data. For running
+      * the renderer as a viewfinder, we set the flag to false. To see the
+      * preview mosaic, we set the flag to true.
+      *
+      * @param flag boolean flag to set the warping to true or false.
+      */
+     public static native void setWarping(boolean flag);
+}
diff --git a/src/com/android/camera/MosaicRendererSurfaceView.java b/src/com/android/camera/MosaicRendererSurfaceView.java
new file mode 100644
index 0000000..6658149
--- /dev/null
+++ b/src/com/android/camera/MosaicRendererSurfaceView.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.pm.ActivityInfo;
+import android.graphics.PixelFormat;
+import android.opengl.GLSurfaceView;
+import android.os.ConditionVariable;
+import android.util.AttributeSet;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+
+public class MosaicRendererSurfaceView extends GLSurfaceView {
+    private static final String TAG = "MosaicRendererSurfaceView";
+    private static final boolean DEBUG = false;
+    private MosaicRendererSurfaceViewRenderer mRenderer;
+    private ConditionVariable mPreviewFrameReadyForProcessing;
+    private boolean mIsLandscapeOrientation = true;
+
+    public MosaicRendererSurfaceView(Context context) {
+        super(context);
+        initialize(context, false, 0, 0);
+    }
+
+    public MosaicRendererSurfaceView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context, false, 0, 0);
+    }
+
+    public MosaicRendererSurfaceView(Context context, boolean translucent,
+            int depth, int stencil) {
+        super(context);
+        initialize(context, translucent, depth, stencil);
+    }
+
+    private void initialize(Context context, boolean translucent, int depth, int stencil) {
+        getDisplayOrientation(context);
+        init(translucent, depth, stencil);
+        setZOrderMediaOverlay(true);
+    }
+
+    private void getDisplayOrientation(Context context) {
+        Activity activity = (PanoramaActivity) context;
+        mIsLandscapeOrientation = (activity.getRequestedOrientation()
+                == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE );
+    }
+
+    private void init(boolean translucent, int depth, int stencil) {
+
+        /* By default, GLSurfaceView() creates a RGB_565 opaque surface.
+         * If we want a translucent one, we should change the surface's
+         * format here, using PixelFormat.TRANSLUCENT for GL Surfaces
+         * is interpreted as any 32-bit surface with alpha by SurfaceFlinger.
+         */
+        if (translucent) {
+            this.getHolder().setFormat(PixelFormat.TRANSLUCENT);
+        }
+
+        /* Setup the context factory for 2.0 rendering.
+         * See ContextFactory class definition below
+         */
+        setEGLContextFactory(new ContextFactory());
+
+        /* We need to choose an EGLConfig that matches the format of
+         * our surface exactly. This is going to be done in our
+         * custom config chooser. See ConfigChooser class definition
+         * below.
+         */
+        setEGLConfigChooser(
+            translucent ? new ConfigChooser(8, 8, 8, 8, depth, stencil) :
+            new ConfigChooser(5, 6, 5, 0, depth, stencil));
+
+        /* Set the renderer responsible for frame rendering */
+        mRenderer = new MosaicRendererSurfaceViewRenderer(mIsLandscapeOrientation);
+        setRenderer(mRenderer);
+        setRenderMode(RENDERMODE_WHEN_DIRTY);
+        mPreviewFrameReadyForProcessing = new ConditionVariable();
+    }
+
+    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
+        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
+            Log.w(TAG, "creating OpenGL ES 2.0 context");
+            checkEglError("Before eglCreateContext", egl);
+            int[] attribList = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
+            EGLContext context = egl.eglCreateContext(
+                display, eglConfig, EGL10.EGL_NO_CONTEXT, attribList);
+            checkEglError("After eglCreateContext", egl);
+            return context;
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
+            egl.eglDestroyContext(display, context);
+        }
+    }
+
+    private static void checkEglError(String prompt, EGL10 egl) {
+        int error;
+        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
+            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
+        }
+    }
+
+    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
+
+        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
+            mRedSize = r;
+            mGreenSize = g;
+            mBlueSize = b;
+            mAlphaSize = a;
+            mDepthSize = depth;
+            mStencilSize = stencil;
+        }
+
+        /* This EGL config specification is used to specify 2.0 rendering.
+         * We use a minimum size of 4 bits for red/green/blue, but will
+         * perform actual matching in chooseConfig() below.
+         */
+        private static final int EGL_OPENGL_ES2_BIT = 4;
+        private static final int[] CONFIG_ATTRIBUTES =
+        {
+            EGL10.EGL_RED_SIZE, 4,
+            EGL10.EGL_GREEN_SIZE, 4,
+            EGL10.EGL_BLUE_SIZE, 4,
+            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+            EGL10.EGL_NONE
+        };
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+
+            /* Get the number of minimally matching EGL configurations
+             */
+            int[] numConfig = new int[1];
+            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, null, 0, numConfig);
+
+            int numConfigs = numConfig[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException("No configs match configSpec");
+            }
+
+            /* Allocate then read the array of minimally matching EGL configs
+             */
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, configs, numConfigs, numConfig);
+
+            if (DEBUG) {
+                 printConfigs(egl, display, configs);
+            }
+            /* Now return the "best" one
+             */
+            return chooseConfig(egl, display, configs);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+
+                // We need at least mDepthSize and mStencilSize bits
+                if (d < mDepthSize || s < mStencilSize)
+                    continue;
+
+                // We want an *exact* match for red/green/blue/alpha
+                int r = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_RED_SIZE, 0);
+                int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                int a = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_ALPHA_SIZE, 0);
+
+                if (r == mRedSize && g == mGreenSize && b == mBlueSize && a == mAlphaSize)
+                    return config;
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private void printConfigs(EGL10 egl, EGLDisplay display,
+            EGLConfig[] configs) {
+            int numConfigs = configs.length;
+            Log.w(TAG, String.format("%d configurations", numConfigs));
+            for (int i = 0; i < numConfigs; i++) {
+                Log.w(TAG, String.format("Configuration %d:\n", i));
+                printConfig(egl, display, configs[i]);
+            }
+        }
+
+        private void printConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig config) {
+            int[] attributes = {
+                    EGL10.EGL_BUFFER_SIZE,
+                    EGL10.EGL_ALPHA_SIZE,
+                    EGL10.EGL_BLUE_SIZE,
+                    EGL10.EGL_GREEN_SIZE,
+                    EGL10.EGL_RED_SIZE,
+                    EGL10.EGL_DEPTH_SIZE,
+                    EGL10.EGL_STENCIL_SIZE,
+                    EGL10.EGL_CONFIG_CAVEAT,
+                    EGL10.EGL_CONFIG_ID,
+                    EGL10.EGL_LEVEL,
+                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
+                    EGL10.EGL_MAX_PBUFFER_PIXELS,
+                    EGL10.EGL_MAX_PBUFFER_WIDTH,
+                    EGL10.EGL_NATIVE_RENDERABLE,
+                    EGL10.EGL_NATIVE_VISUAL_ID,
+                    EGL10.EGL_NATIVE_VISUAL_TYPE,
+                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
+                    EGL10.EGL_SAMPLES,
+                    EGL10.EGL_SAMPLE_BUFFERS,
+                    EGL10.EGL_SURFACE_TYPE,
+                    EGL10.EGL_TRANSPARENT_TYPE,
+                    EGL10.EGL_TRANSPARENT_RED_VALUE,
+                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
+                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
+                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
+                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
+                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
+                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
+                    EGL10.EGL_LUMINANCE_SIZE,
+                    EGL10.EGL_ALPHA_MASK_SIZE,
+                    EGL10.EGL_COLOR_BUFFER_TYPE,
+                    EGL10.EGL_RENDERABLE_TYPE,
+                    0x3042 // EGL10.EGL_CONFORMANT
+            };
+            String[] names = {
+                    "EGL_BUFFER_SIZE",
+                    "EGL_ALPHA_SIZE",
+                    "EGL_BLUE_SIZE",
+                    "EGL_GREEN_SIZE",
+                    "EGL_RED_SIZE",
+                    "EGL_DEPTH_SIZE",
+                    "EGL_STENCIL_SIZE",
+                    "EGL_CONFIG_CAVEAT",
+                    "EGL_CONFIG_ID",
+                    "EGL_LEVEL",
+                    "EGL_MAX_PBUFFER_HEIGHT",
+                    "EGL_MAX_PBUFFER_PIXELS",
+                    "EGL_MAX_PBUFFER_WIDTH",
+                    "EGL_NATIVE_RENDERABLE",
+                    "EGL_NATIVE_VISUAL_ID",
+                    "EGL_NATIVE_VISUAL_TYPE",
+                    "EGL_PRESERVED_RESOURCES",
+                    "EGL_SAMPLES",
+                    "EGL_SAMPLE_BUFFERS",
+                    "EGL_SURFACE_TYPE",
+                    "EGL_TRANSPARENT_TYPE",
+                    "EGL_TRANSPARENT_RED_VALUE",
+                    "EGL_TRANSPARENT_GREEN_VALUE",
+                    "EGL_TRANSPARENT_BLUE_VALUE",
+                    "EGL_BIND_TO_TEXTURE_RGB",
+                    "EGL_BIND_TO_TEXTURE_RGBA",
+                    "EGL_MIN_SWAP_INTERVAL",
+                    "EGL_MAX_SWAP_INTERVAL",
+                    "EGL_LUMINANCE_SIZE",
+                    "EGL_ALPHA_MASK_SIZE",
+                    "EGL_COLOR_BUFFER_TYPE",
+                    "EGL_RENDERABLE_TYPE",
+                    "EGL_CONFORMANT"
+            };
+            int[] value = new int[1];
+            for (int i = 0; i < attributes.length; i++) {
+                int attribute = attributes[i];
+                String name = names[i];
+                if (egl.eglGetConfigAttrib(display, config, attribute, value)) {
+                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
+                } else {
+                    // Log.w(TAG, String.format("  %s: failed\n", name));
+                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
+                }
+            }
+        }
+
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+        private int[] mValue = new int[1];
+    }
+
+    public void lockPreviewReadyFlag() {
+        mPreviewFrameReadyForProcessing.close();
+    }
+
+    private void unlockPreviewReadyFlag() {
+        mPreviewFrameReadyForProcessing.open();
+    }
+
+    public void waitUntilPreviewReady() {
+        mPreviewFrameReadyForProcessing.block();
+    }
+
+    public void setReady() {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.setReady();
+            }
+        });
+    }
+
+    public void preprocess(final float[] transformMatrix) {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.preprocess(transformMatrix);
+            }
+        });
+    }
+
+    public void transferGPUtoCPU() {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.transferGPUtoCPU();
+                unlockPreviewReadyFlag();
+            }
+        });
+    }
+
+    public void setWarping(final boolean flag) {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.setWarping(flag);
+            }
+        });
+    }
+
+    public MosaicRendererSurfaceViewRenderer getRenderer() {
+        return mRenderer;
+    }
+
+}
diff --git a/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java b/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
new file mode 100755
index 0000000..19d84d2
--- /dev/null
+++ b/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.opengl.GLSurfaceView;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+public class MosaicRendererSurfaceViewRenderer implements GLSurfaceView.Renderer
+{
+    private static final String TAG = "MosaicRendererSurfaceViewRenderer";
+    private boolean mIsLandscapeOrientation;
+
+    private MosaicSurfaceCreateListener mSurfaceCreateListener;
+
+    public MosaicRendererSurfaceViewRenderer(boolean isLandscapeOrientation) {
+        mIsLandscapeOrientation = isLandscapeOrientation;
+    }
+
+    /** A callback to be called when the surface is created */
+    public interface MosaicSurfaceCreateListener {
+        public void onMosaicSurfaceCreated(final int surface);
+        public void onMosaicSurfaceChanged();
+    }
+
+    @Override
+    public void onDrawFrame(GL10 gl) {
+        MosaicRenderer.step();
+    }
+
+    @Override
+    public void onSurfaceChanged(GL10 gl, int width, int height) {
+        MosaicRenderer.reset(width, height, mIsLandscapeOrientation);
+        Log.i(TAG, "Renderer: onSurfaceChanged");
+        if (mSurfaceCreateListener != null) {
+            mSurfaceCreateListener.onMosaicSurfaceChanged();
+        }
+    }
+
+    @Override
+    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
+        Log.i(TAG, "onSurfaceCreated");
+        if (mSurfaceCreateListener != null) {
+            mSurfaceCreateListener.onMosaicSurfaceCreated(MosaicRenderer.init());
+        }
+    }
+
+    public void setMosaicSurfaceCreateListener(MosaicSurfaceCreateListener listener) {
+        mSurfaceCreateListener = listener;
+    }
+
+    public void setReady() {
+        MosaicRenderer.ready();
+    }
+
+    public void preprocess(float[] transformMatrix) {
+        MosaicRenderer.preprocess(transformMatrix);
+    }
+
+    public void transferGPUtoCPU() {
+        MosaicRenderer.transferGPUtoCPU();
+    }
+
+    public void setWarping(boolean flag) {
+        MosaicRenderer.setWarping(flag);
+    }
+}
diff --git a/src/com/android/camera/PanoProgressBar.java b/src/com/android/camera/PanoProgressBar.java
new file mode 100644
index 0000000..979e7f0
--- /dev/null
+++ b/src/com/android/camera/PanoProgressBar.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+class PanoProgressBar extends ImageView {
+    private static final String TAG = "PanoProgressBar";
+    public static final int DIRECTION_NONE = 0;
+    public static final int DIRECTION_LEFT = 1;
+    public static final int DIRECTION_RIGHT = 2;
+    private float mProgress = 0;
+    private float mMaxProgress = 0;
+    private float mLeftMostProgress = 0;
+    private float mRightMostProgress = 0;
+    private float mProgressOffset = 0;
+    private float mIndicatorWidth = 0;
+    private int mDirection = 0;
+    private final Paint mBackgroundPaint = new Paint();
+    private final Paint mDoneAreaPaint = new Paint();
+    private final Paint mIndicatorPaint = new Paint();
+    private float mWidth;
+    private float mHeight;
+    private RectF mDrawBounds;
+    private OnDirectionChangeListener mListener = null;
+
+    public interface OnDirectionChangeListener {
+        public void onDirectionChange(int direction);
+    }
+
+    public PanoProgressBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mDoneAreaPaint.setStyle(Paint.Style.FILL);
+        mDoneAreaPaint.setAlpha(0xff);
+
+        mBackgroundPaint.setStyle(Paint.Style.FILL);
+        mBackgroundPaint.setAlpha(0xff);
+
+        mIndicatorPaint.setStyle(Paint.Style.FILL);
+        mIndicatorPaint.setAlpha(0xff);
+
+        mDrawBounds = new RectF();
+    }
+
+    public void setOnDirectionChangeListener(OnDirectionChangeListener l) {
+        mListener = l;
+    }
+
+    private void setDirection(int direction) {
+        if (mDirection != direction) {
+            mDirection = direction;
+            if (mListener != null) {
+                mListener.onDirectionChange(mDirection);
+            }
+            invalidate();
+        }
+    }
+
+    public int getDirection() {
+        return mDirection;
+    }
+
+    public void setBackgroundColor(int color) {
+        mBackgroundPaint.setColor(color);
+        invalidate();
+    }
+
+    public void setDoneColor(int color) {
+        mDoneAreaPaint.setColor(color);
+        invalidate();
+    }
+
+    public void setIndicatorColor(int color) {
+        mIndicatorPaint.setColor(color);
+        invalidate();
+    }
+
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        mWidth = w;
+        mHeight = h;
+        mDrawBounds.set(0, 0, mWidth, mHeight);
+    }
+
+    public void setMaxProgress(int progress) {
+        mMaxProgress = progress;
+    }
+
+    public void setIndicatorWidth(float w) {
+        mIndicatorWidth = w;
+        invalidate();
+    }
+
+    public void setRightIncreasing(boolean rightIncreasing) {
+        if (rightIncreasing) {
+            mLeftMostProgress = 0;
+            mRightMostProgress = 0;
+            mProgressOffset = 0;
+            setDirection(DIRECTION_RIGHT);
+        } else {
+            mLeftMostProgress = mWidth;
+            mRightMostProgress = mWidth;
+            mProgressOffset = mWidth;
+            setDirection(DIRECTION_LEFT);
+        }
+        invalidate();
+    }
+
+    public void setProgress(int progress) {
+        // The panning direction will be decided after user pan more than 10 degrees in one
+        // direction.
+        if (mDirection == DIRECTION_NONE) {
+            if (progress > 10) {
+                setRightIncreasing(true);
+            } else if (progress < -10) {
+                setRightIncreasing(false);
+            }
+        }
+        // mDirection might be modified by setRightIncreasing() above. Need to check again.
+        if (mDirection != DIRECTION_NONE) {
+            mProgress = progress * mWidth / mMaxProgress + mProgressOffset;
+            // value bounds.
+            mProgress = Math.min(mWidth, Math.max(0, mProgress));
+            if (mDirection == DIRECTION_RIGHT) {
+                // The right most progress is adjusted.
+                mRightMostProgress = Math.max(mRightMostProgress, mProgress);
+            }
+            if (mDirection == DIRECTION_LEFT) {
+                // The left most progress is adjusted.
+                mLeftMostProgress = Math.min(mLeftMostProgress, mProgress);
+            }
+            invalidate();
+        }
+    }
+
+    public void reset() {
+        mProgress = 0;
+        mProgressOffset = 0;
+        setDirection(DIRECTION_NONE);
+        invalidate();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        // the background
+        canvas.drawRect(mDrawBounds, mBackgroundPaint);
+        if (mDirection != DIRECTION_NONE) {
+            // the progress area
+            canvas.drawRect(mLeftMostProgress, mDrawBounds.top, mRightMostProgress,
+                    mDrawBounds.bottom, mDoneAreaPaint);
+            // the indication bar
+            float l;
+            float r;
+            if (mDirection == DIRECTION_RIGHT) {
+                l = Math.max(mProgress - mIndicatorWidth, 0f);
+                r = mProgress;
+            } else {
+                l = mProgress;
+                r = Math.min(mProgress + mIndicatorWidth, mWidth);
+            }
+            canvas.drawRect(l, mDrawBounds.top, r, mDrawBounds.bottom, mIndicatorPaint);
+        }
+
+        // draw the mask image on the top for shaping.
+        super.onDraw(canvas);
+    }
+}
diff --git a/src/com/android/camera/PanoUtil.java b/src/com/android/camera/PanoUtil.java
new file mode 100644
index 0000000..4a7d9d8
--- /dev/null
+++ b/src/com/android/camera/PanoUtil.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+public class PanoUtil {
+    public static String createName(String format, long dateTaken) {
+        Date date = new Date(dateTaken);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(format);
+        return dateFormat.format(date);
+    }
+
+    // TODO: Add comments about the range of these two arguments.
+    public static double calculateDifferenceBetweenAngles(double firstAngle,
+            double secondAngle) {
+        double difference1 = (secondAngle - firstAngle) % 360;
+        if (difference1 < 0) {
+            difference1 += 360;
+        }
+
+        double difference2 = (firstAngle - secondAngle) % 360;
+        if (difference2 < 0) {
+            difference2 += 360;
+        }
+
+        return Math.min(difference1, difference2);
+    }
+
+    public static void decodeYUV420SPQuarterRes(int[] rgb, byte[] yuv420sp, int width, int height) {
+        final int frameSize = width * height;
+
+        for (int j = 0, ypd = 0; j < height; j += 4) {
+            int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;
+            for (int i = 0; i < width; i += 4, ypd++) {
+                int y = (0xff & ((int) yuv420sp[j * width + i])) - 16;
+                if (y < 0) {
+                    y = 0;
+                }
+                if ((i & 1) == 0) {
+                    v = (0xff & yuv420sp[uvp++]) - 128;
+                    u = (0xff & yuv420sp[uvp++]) - 128;
+                    uvp += 2;  // Skip the UV values for the 4 pixels skipped in between
+                }
+                int y1192 = 1192 * y;
+                int r = (y1192 + 1634 * v);
+                int g = (y1192 - 833 * v - 400 * u);
+                int b = (y1192 + 2066 * u);
+
+                if (r < 0) {
+                    r = 0;
+                } else if (r > 262143) {
+                    r = 262143;
+                }
+                if (g < 0) {
+                    g = 0;
+                } else if (g > 262143) {
+                    g = 262143;
+                }
+                if (b < 0) {
+                    b = 0;
+                } else if (b > 262143) {
+                    b = 262143;
+                }
+
+                rgb[ypd] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) |
+                        ((b >> 10) & 0xff);
+            }
+        }
+    }
+}
diff --git a/src/com/android/camera/PanoramaActivity.java b/src/com/android/camera/PanoramaActivity.java
new file mode 100755
index 0000000..01fb095
--- /dev/null
+++ b/src/com/android/camera/PanoramaActivity.java
@@ -0,0 +1,1170 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import com.android.camera.ActivityBase;
+import com.android.camera.CameraDisabledException;
+import com.android.camera.CameraHardwareException;
+import com.android.camera.CameraHolder;
+import com.android.camera.Exif;
+import com.android.camera.MenuHelper;
+import com.android.camera.ModePicker;
+import com.android.camera.OnClickAttr;
+import com.android.camera.R;
+import com.android.camera.RotateDialogController;
+import com.android.camera.ShutterButton;
+import com.android.camera.Storage;
+import com.android.camera.Thumbnail;
+import com.android.camera.Util;
+import com.android.camera.ui.PopupManager;
+import com.android.camera.ui.Rotatable;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.ui.SharePopup;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.content.pm.ActivityInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ImageFormat;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.SurfaceTexture;
+import android.graphics.YuvImage;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+import android.hardware.Sensor;
+import android.hardware.SensorManager;
+import android.media.ExifInterface;
+import android.media.MediaActionSound;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.PowerManager;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.OrientationEventListener;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Activity to handle panorama capturing.
+ */
+public class PanoramaActivity extends ActivityBase implements
+        ModePicker.OnModeChangeListener, SurfaceTexture.OnFrameAvailableListener,
+        ShutterButton.OnShutterButtonListener,
+        MosaicRendererSurfaceViewRenderer.MosaicSurfaceCreateListener {
+    public static final int DEFAULT_SWEEP_ANGLE = 160;
+    public static final int DEFAULT_BLEND_MODE = Mosaic.BLENDTYPE_HORIZONTAL;
+    public static final int DEFAULT_CAPTURE_PIXELS = 960 * 720;
+
+    private static final int MSG_LOW_RES_FINAL_MOSAIC_READY = 1;
+    private static final int MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL = 2;
+    private static final int MSG_GENERATE_FINAL_MOSAIC_ERROR = 3;
+    private static final int MSG_RESET_TO_PREVIEW = 4;
+    private static final int MSG_CLEAR_SCREEN_DELAY = 5;
+
+    private static final int SCREEN_DELAY = 2 * 60 * 1000;
+
+    private static final String TAG = "PanoramaActivity";
+    private static final int PREVIEW_STOPPED = 0;
+    private static final int PREVIEW_ACTIVE = 1;
+    private static final int CAPTURE_STATE_VIEWFINDER = 0;
+    private static final int CAPTURE_STATE_MOSAIC = 1;
+
+    // Speed is in unit of deg/sec
+    private static final float PANNING_SPEED_THRESHOLD = 20f;
+
+    // Ratio of nanosecond to second
+    private static final float NS2S = 1.0f / 1000000000.0f;
+
+    private boolean mPausing;
+
+    private View mPanoLayout;
+    private View mCaptureLayout;
+    private View mReviewLayout;
+    private ImageView mReview;
+    private RotateLayout mCaptureIndicator;
+    private PanoProgressBar mPanoProgressBar;
+    private PanoProgressBar mSavingProgressBar;
+    private View mFastIndicationBorder;
+    private View mLeftIndicator;
+    private View mRightIndicator;
+    private MosaicRendererSurfaceView mMosaicView;
+    private TextView mTooFastPrompt;
+    private ShutterButton mShutterButton;
+    private Object mWaitObject = new Object();
+
+    private String mPreparePreviewString;
+    private String mDialogTitle;
+    private String mDialogOkString;
+    private String mDialogPanoramaFailedString;
+
+    private int mIndicatorColor;
+    private int mIndicatorColorFast;
+
+    private float mCompassValueX;
+    private float mCompassValueY;
+    private float mCompassValueXStart;
+    private float mCompassValueYStart;
+    private float mCompassValueXStartBuffer;
+    private float mCompassValueYStartBuffer;
+    private int mCompassThreshold;
+    private int mTraversedAngleX;
+    private int mTraversedAngleY;
+    private long mTimestamp;
+
+    private RotateImageView mThumbnailView;
+    private Thumbnail mThumbnail;
+    private SharePopup mSharePopup;
+
+    private int mPreviewWidth;
+    private int mPreviewHeight;
+    private int mCameraState;
+    private int mCaptureState;
+    private SensorManager mSensorManager;
+    private Sensor mSensor;
+    private PowerManager.WakeLock mPartialWakeLock;
+    private ModePicker mModePicker;
+    private MosaicFrameProcessor mMosaicFrameProcessor;
+    private long mTimeTaken;
+    private Handler mMainHandler;
+    private SurfaceTexture mSurfaceTexture;
+    private boolean mThreadRunning;
+    private boolean mCancelComputation;
+    private float[] mTransformMatrix;
+    private float mHorizontalViewAngle;
+    private float mVerticalViewAngle;
+
+    // Prefer FOCUS_MODE_INFINITY to FOCUS_MODE_CONTINUOUS_VIDEO because of
+    // getting a better image quality by the former.
+    private String mTargetFocusMode = Parameters.FOCUS_MODE_INFINITY;
+
+    private PanoOrientationEventListener mOrientationEventListener;
+    // The value could be 0, 90, 180, 270 for the 4 different orientations measured in clockwise
+    // respectively.
+    private int mDeviceOrientation;
+    private int mDeviceOrientationAtCapture;
+    private int mCameraOrientation;
+    private int mOrientationCompensation;
+
+    private RotateDialogController mRotateDialog;
+
+    private MediaActionSound mCameraSound;
+
+    private class MosaicJpeg {
+        public MosaicJpeg(byte[] data, int width, int height) {
+            this.data = data;
+            this.width = width;
+            this.height = height;
+            this.isValid = true;
+        }
+
+        public MosaicJpeg() {
+            this.data = null;
+            this.width = 0;
+            this.height = 0;
+            this.isValid = false;
+        }
+
+        public final byte[] data;
+        public final int width;
+        public final int height;
+        public final boolean isValid;
+    }
+
+    private class PanoOrientationEventListener extends OrientationEventListener {
+        public PanoOrientationEventListener(Context context) {
+            super(context);
+        }
+
+        @Override
+        public void onOrientationChanged(int orientation) {
+            // We keep the last known orientation. So if the user first orient
+            // the camera then point the camera to floor or sky, we still have
+            // the correct orientation.
+            if (orientation == ORIENTATION_UNKNOWN) return;
+            mDeviceOrientation = Util.roundOrientation(orientation, mDeviceOrientation);
+            // When the screen is unlocked, display rotation may change. Always
+            // calculate the up-to-date orientationCompensation.
+            int orientationCompensation = mDeviceOrientation
+                    + Util.getDisplayRotation(PanoramaActivity.this);
+            if (mOrientationCompensation != orientationCompensation) {
+                mOrientationCompensation = orientationCompensation;
+                setOrientationIndicator(mOrientationCompensation);
+            }
+        }
+    }
+
+    private void setOrientationIndicator(int degree) {
+        if (mSharePopup != null) mSharePopup.setOrientation(degree);
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        super.onCreateOptionsMenu(menu);
+
+        addBaseMenuItems(menu);
+        return true;
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        super.onPrepareOptionsMenu(menu);
+        // Only show the menu when idle.
+        boolean idle = (mCaptureState == CAPTURE_STATE_VIEWFINDER && !mThreadRunning);
+        for (int i = 0; i < menu.size(); i++) {
+            MenuItem item = menu.getItem(i);
+            item.setVisible(idle);
+            item.setEnabled(idle);
+        }
+
+        return true;
+    }
+
+    private void addBaseMenuItems(Menu menu) {
+        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_CAMERA, new Runnable() {
+            public void run() {
+                switchToOtherMode(ModePicker.MODE_CAMERA);
+            }
+        });
+        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_VIDEO, new Runnable() {
+            public void run() {
+                switchToOtherMode(ModePicker.MODE_VIDEO);
+            }
+        });
+    }
+
+    @Override
+    public void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+
+        Window window = getWindow();
+        Util.enterLightsOutMode(window);
+        Util.initializeScreenBrightness(window, getContentResolver());
+
+        createContentView();
+
+        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
+        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
+        if (mSensor == null) {
+            mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
+        }
+        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        mPartialWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Panorama");
+
+        mOrientationEventListener = new PanoOrientationEventListener(this);
+
+        mTransformMatrix = new float[16];
+
+        mPreparePreviewString =
+                getResources().getString(R.string.pano_dialog_prepare_preview);
+        mDialogTitle = getResources().getString(R.string.pano_dialog_title);
+        mDialogOkString = getResources().getString(R.string.dialog_ok);
+        mDialogPanoramaFailedString =
+                getResources().getString(R.string.pano_dialog_panorama_failed);
+        mCameraSound = new MediaActionSound();
+
+        mMainHandler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                switch (msg.what) {
+                    case MSG_LOW_RES_FINAL_MOSAIC_READY:
+                        onBackgroundThreadFinished();
+                        showFinalMosaic((Bitmap) msg.obj);
+                        saveHighResMosaic();
+                        break;
+                    case MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL:
+                        onBackgroundThreadFinished();
+                        // If the activity is paused, save the thumbnail to the file here.
+                        // If not, it will be saved in onPause.
+                        if (mPausing) saveThumbnailToFile();
+                        // Set the thumbnail bitmap here because mThumbnailView must be accessed
+                        // from the UI thread.
+                        updateThumbnailButton();
+
+                        // Share popup may still have the reference to the old thumbnail. Clear it.
+                        mSharePopup = null;
+                        resetToPreview();
+                        break;
+                    case MSG_GENERATE_FINAL_MOSAIC_ERROR:
+                        onBackgroundThreadFinished();
+                        if (mPausing) {
+                            resetToPreview();
+                        } else {
+                            mRotateDialog.showAlertDialog(
+                                    mDialogTitle, mDialogPanoramaFailedString,
+                                    mDialogOkString, new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            resetToPreview();
+                                        }},
+                                    null, null);
+                        }
+                        break;
+                    case MSG_RESET_TO_PREVIEW:
+                        onBackgroundThreadFinished();
+                        resetToPreview();
+                        break;
+                    case MSG_CLEAR_SCREEN_DELAY:
+                        getWindow().clearFlags(WindowManager.LayoutParams.
+                                FLAG_KEEP_SCREEN_ON);
+                        break;
+                }
+                clearMosaicFrameProcessorIfNeeded();
+            }
+        };
+    }
+
+    private void setupCamera() throws CameraHardwareException, CameraDisabledException {
+        openCamera();
+        Parameters parameters = mCameraDevice.getParameters();
+        setupCaptureParams(parameters);
+        configureCamera(parameters);
+    }
+
+    private void releaseCamera() {
+        if (mCameraDevice != null) {
+            mCameraDevice.setPreviewCallbackWithBuffer(null);
+            CameraHolder.instance().release();
+            mCameraDevice = null;
+            mCameraState = PREVIEW_STOPPED;
+        }
+    }
+
+    private void openCamera() throws CameraHardwareException, CameraDisabledException {
+        int backCameraId = CameraHolder.instance().getBackCameraId();
+        mCameraDevice = Util.openCamera(this, backCameraId);
+        mCameraOrientation = Util.getCameraOrientation(backCameraId);
+    }
+
+    private boolean findBestPreviewSize(List<Size> supportedSizes, boolean need4To3,
+            boolean needSmaller) {
+        int pixelsDiff = DEFAULT_CAPTURE_PIXELS;
+        boolean hasFound = false;
+        for (Size size : supportedSizes) {
+            int h = size.height;
+            int w = size.width;
+            // we only want 4:3 format.
+            int d = DEFAULT_CAPTURE_PIXELS - h * w;
+            if (needSmaller && d < 0) { // no bigger preview than 960x720.
+                continue;
+            }
+            if (need4To3 && (h * 4 != w * 3)) {
+                continue;
+            }
+            d = Math.abs(d);
+            if (d < pixelsDiff) {
+                mPreviewWidth = w;
+                mPreviewHeight = h;
+                pixelsDiff = d;
+                hasFound = true;
+            }
+        }
+        return hasFound;
+    }
+
+    private void setupCaptureParams(Parameters parameters) {
+        List<Size> supportedSizes = parameters.getSupportedPreviewSizes();
+        if (!findBestPreviewSize(supportedSizes, true, true)) {
+            Log.w(TAG, "No 4:3 ratio preview size supported.");
+            if (!findBestPreviewSize(supportedSizes, false, true)) {
+                Log.w(TAG, "Can't find a supported preview size smaller than 960x720.");
+                findBestPreviewSize(supportedSizes, false, false);
+            }
+        }
+        Log.v(TAG, "preview h = " + mPreviewHeight + " , w = " + mPreviewWidth);
+        parameters.setPreviewSize(mPreviewWidth, mPreviewHeight);
+
+        List<int[]> frameRates = parameters.getSupportedPreviewFpsRange();
+        int last = frameRates.size() - 1;
+        int minFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MIN_INDEX];
+        int maxFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MAX_INDEX];
+        parameters.setPreviewFpsRange(minFps, maxFps);
+        Log.v(TAG, "preview fps: " + minFps + ", " + maxFps);
+
+        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+        if (supportedFocusModes.indexOf(mTargetFocusMode) >= 0) {
+            parameters.setFocusMode(mTargetFocusMode);
+        } else {
+            // Use the default focus mode and log a message
+            Log.w(TAG, "Cannot set the focus mode to " + mTargetFocusMode +
+                  " becuase the mode is not supported.");
+        }
+
+        parameters.setRecordingHint(false);
+
+        mHorizontalViewAngle = parameters.getHorizontalViewAngle();
+        mVerticalViewAngle =  parameters.getVerticalViewAngle();
+    }
+
+    public int getPreviewBufSize() {
+        PixelFormat pixelInfo = new PixelFormat();
+        PixelFormat.getPixelFormatInfo(mCameraDevice.getParameters().getPreviewFormat(), pixelInfo);
+        // TODO: remove this extra 32 byte after the driver bug is fixed.
+        return (mPreviewWidth * mPreviewHeight * pixelInfo.bitsPerPixel / 8) + 32;
+    }
+
+    private void configureCamera(Parameters parameters) {
+        mCameraDevice.setParameters(parameters);
+    }
+
+    private boolean switchToOtherMode(int mode) {
+        if (isFinishing()) {
+            return false;
+        }
+        MenuHelper.gotoMode(mode, this);
+        finish();
+        return true;
+    }
+
+    public boolean onModeChanged(int mode) {
+        if (mode != ModePicker.MODE_PANORAMA) {
+            return switchToOtherMode(mode);
+        } else {
+            return true;
+        }
+    }
+
+    @Override
+    public void onMosaicSurfaceChanged() {
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                // If panorama is generating low res or high res mosaic, it
+                // means users exit and come back to panorama. Do not start the
+                // preview. Preview will be started after final mosaic is
+                // generated.
+                if (!mPausing) {
+                    startCameraPreview();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void onMosaicSurfaceCreated(final int textureID) {
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (mSurfaceTexture != null) {
+                    mSurfaceTexture.release();
+                }
+                mSurfaceTexture = new SurfaceTexture(textureID);
+                if (!mPausing) {
+                    mSurfaceTexture.setOnFrameAvailableListener(PanoramaActivity.this);
+                }
+            }
+        });
+    }
+
+    public void runViewFinder() {
+        mMosaicView.setWarping(false);
+        // Call preprocess to render it to low-res and high-res RGB textures.
+        mMosaicView.preprocess(mTransformMatrix);
+        mMosaicView.setReady();
+        mMosaicView.requestRender();
+    }
+
+    public void runMosaicCapture() {
+        mMosaicView.setWarping(true);
+        // Call preprocess to render it to low-res and high-res RGB textures.
+        mMosaicView.preprocess(mTransformMatrix);
+        // Lock the conditional variable to ensure the order of transferGPUtoCPU and
+        // mMosaicFrame.processFrame().
+        mMosaicView.lockPreviewReadyFlag();
+        // Now, transfer the textures from GPU to CPU memory for processing
+        mMosaicView.transferGPUtoCPU();
+        // Wait on the condition variable (will be opened when GPU->CPU transfer is done).
+        mMosaicView.waitUntilPreviewReady();
+        mMosaicFrameProcessor.processFrame();
+    }
+
+    public synchronized void onFrameAvailable(SurfaceTexture surface) {
+        /* This function may be called by some random thread,
+         * so let's be safe and use synchronize. No OpenGL calls can be done here.
+         */
+        // Frames might still be available after the activity is paused. If we call onFrameAvailable
+        // after pausing, the GL thread will crash.
+        if (mPausing) return;
+
+        // Updating the texture should be done in the GL thread which mMosaicView is attached.
+        mMosaicView.queueEvent(new Runnable() {
+            @Override
+            public void run() {
+                // Check if the activity is paused here can speed up the onPause() process.
+                if (mPausing) return;
+                mSurfaceTexture.updateTexImage();
+                mSurfaceTexture.getTransformMatrix(mTransformMatrix);
+            }
+        });
+        // Update the transformation matrix for mosaic pre-process.
+        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
+            runViewFinder();
+        } else {
+            runMosaicCapture();
+        }
+    }
+
+    private void hideDirectionIndicators() {
+        mLeftIndicator.setVisibility(View.GONE);
+        mRightIndicator.setVisibility(View.GONE);
+    }
+
+    private void showDirectionIndicators(int direction) {
+        switch (direction) {
+            case PanoProgressBar.DIRECTION_NONE:
+                mLeftIndicator.setVisibility(View.VISIBLE);
+                mRightIndicator.setVisibility(View.VISIBLE);
+                break;
+            case PanoProgressBar.DIRECTION_LEFT:
+                mLeftIndicator.setVisibility(View.VISIBLE);
+                mRightIndicator.setVisibility(View.GONE);
+                break;
+            case PanoProgressBar.DIRECTION_RIGHT:
+                mLeftIndicator.setVisibility(View.GONE);
+                mRightIndicator.setVisibility(View.VISIBLE);
+                break;
+        }
+    }
+
+    public void startCapture() {
+        // Reset values so we can do this again.
+        mCancelComputation = false;
+        mTimeTaken = System.currentTimeMillis();
+        mCaptureState = CAPTURE_STATE_MOSAIC;
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan_recording);
+        mCaptureIndicator.setVisibility(View.VISIBLE);
+        showDirectionIndicators(PanoProgressBar.DIRECTION_NONE);
+        mThumbnailView.setEnabled(false);
+
+        mCompassValueXStart = mCompassValueXStartBuffer;
+        mCompassValueYStart = mCompassValueYStartBuffer;
+        mTimestamp = 0;
+
+        mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener() {
+            @Override
+            public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
+                    float progressX, float progressY) {
+                float accumulatedHorizontalAngle = progressX * mHorizontalViewAngle;
+                float accumulatedVerticalAngle = progressY * mVerticalViewAngle;
+                if (isFinished
+                        || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE)
+                        || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)) {
+                    stopCapture(false);
+                } else {
+                    float panningRateXInDegree = panningRateX * mHorizontalViewAngle;
+                    float panningRateYInDegree = panningRateY * mVerticalViewAngle;
+                    updateProgress(panningRateXInDegree, panningRateYInDegree,
+                            accumulatedHorizontalAngle, accumulatedVerticalAngle);
+                }
+            }
+        });
+
+        if (mModePicker != null) mModePicker.setEnabled(false);
+
+        mPanoProgressBar.reset();
+        // TODO: calculate the indicator width according to different devices to reflect the actual
+        // angle of view of the camera device.
+        mPanoProgressBar.setIndicatorWidth(20);
+        mPanoProgressBar.setMaxProgress(DEFAULT_SWEEP_ANGLE);
+        mPanoProgressBar.setVisibility(View.VISIBLE);
+        mDeviceOrientationAtCapture = mDeviceOrientation;
+        keepScreenOn();
+    }
+
+    private void stopCapture(boolean aborted) {
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+        mCaptureIndicator.setVisibility(View.GONE);
+        hideTooFastIndication();
+        hideDirectionIndicators();
+        mThumbnailView.setEnabled(true);
+
+        mMosaicFrameProcessor.setProgressListener(null);
+        stopCameraPreview();
+
+        mSurfaceTexture.setOnFrameAvailableListener(null);
+
+        if (!aborted && !mThreadRunning) {
+            mRotateDialog.showWaitingDialog(mPreparePreviewString);
+            runBackgroundThread(new Thread() {
+                @Override
+                public void run() {
+                    MosaicJpeg jpeg = generateFinalMosaic(false);
+
+                    if (jpeg != null && jpeg.isValid) {
+                        Bitmap bitmap = null;
+                        bitmap = BitmapFactory.decodeByteArray(jpeg.data, 0, jpeg.data.length);
+                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
+                                MSG_LOW_RES_FINAL_MOSAIC_READY, bitmap));
+                    } else {
+                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
+                                MSG_RESET_TO_PREVIEW));
+                    }
+                }
+            });
+        }
+        // do we have to wait for the thread to complete before enabling this?
+        if (mModePicker != null) mModePicker.setEnabled(true);
+        keepScreenOnAwhile();
+    }
+
+    private void showTooFastIndication() {
+        mTooFastPrompt.setVisibility(View.VISIBLE);
+        mFastIndicationBorder.setVisibility(View.VISIBLE);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColorFast);
+        mLeftIndicator.setEnabled(true);
+        mRightIndicator.setEnabled(true);
+    }
+
+    private void hideTooFastIndication() {
+        mTooFastPrompt.setVisibility(View.GONE);
+        mFastIndicationBorder.setVisibility(View.GONE);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
+        mLeftIndicator.setEnabled(false);
+        mRightIndicator.setEnabled(false);
+    }
+
+    private void updateProgress(float panningRateXInDegree, float panningRateYInDegree,
+            float progressHorizontalAngle, float progressVerticalAngle) {
+        mMosaicView.setReady();
+        mMosaicView.requestRender();
+
+        // TODO: Now we just display warning message by the panning speed.
+        // Since we only support horizontal panning, we should display a warning message
+        // in UI when there're significant vertical movements.
+        if ((Math.abs(panningRateXInDegree) > PANNING_SPEED_THRESHOLD)
+            || (Math.abs(panningRateYInDegree) > PANNING_SPEED_THRESHOLD)) {
+            showTooFastIndication();
+        } else {
+            hideTooFastIndication();
+        }
+        int angleInMajorDirection =
+                (Math.abs(progressHorizontalAngle) > Math.abs(progressVerticalAngle))
+                ? (int) progressHorizontalAngle
+                : (int) progressVerticalAngle;
+        mPanoProgressBar.setProgress((angleInMajorDirection));
+    }
+
+    private void createContentView() {
+        setContentView(R.layout.panorama);
+
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+
+        Resources appRes = getResources();
+
+        mCaptureLayout = (View) findViewById(R.id.pano_capture_layout);
+        mPanoProgressBar = (PanoProgressBar) findViewById(R.id.pano_pan_progress_bar);
+        mPanoProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
+        mPanoProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_done));
+        mIndicatorColor = appRes.getColor(R.color.pano_progress_indication);
+        mIndicatorColorFast = appRes.getColor(R.color.pano_progress_indication_fast);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
+        mPanoProgressBar.setOnDirectionChangeListener(
+                new PanoProgressBar.OnDirectionChangeListener () {
+                    @Override
+                    public void onDirectionChange(int direction) {
+                        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
+                            showDirectionIndicators(direction);
+                        }
+                    }
+                });
+
+        mLeftIndicator = (ImageView) findViewById(R.id.pano_pan_left_indicator);
+        mRightIndicator = (ImageView) findViewById(R.id.pano_pan_right_indicator);
+        mLeftIndicator.setEnabled(false);
+        mRightIndicator.setEnabled(false);
+        mTooFastPrompt = (TextView) findViewById(R.id.pano_capture_too_fast_textview);
+        mFastIndicationBorder = (View) findViewById(R.id.pano_speed_indication_border);
+
+        mSavingProgressBar = (PanoProgressBar) findViewById(R.id.pano_saving_progress_bar);
+        mSavingProgressBar.setIndicatorWidth(0);
+        mSavingProgressBar.setMaxProgress(100);
+        mSavingProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
+        mSavingProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_indication));
+
+        mCaptureIndicator = (RotateLayout) findViewById(R.id.pano_capture_indicator);
+
+        mThumbnailView = (RotateImageView) findViewById(R.id.thumbnail);
+        mThumbnailView.enableFilter(false);
+
+        mReviewLayout = (View) findViewById(R.id.pano_review_layout);
+        mReview = (ImageView) findViewById(R.id.pano_reviewarea);
+        mMosaicView = (MosaicRendererSurfaceView) findViewById(R.id.pano_renderer);
+        mMosaicView.getRenderer().setMosaicSurfaceCreateListener(this);
+
+        mModePicker = (ModePicker) findViewById(R.id.mode_picker);
+        mModePicker.setVisibility(View.VISIBLE);
+        mModePicker.setOnModeChangeListener(this);
+        mModePicker.setCurrentMode(ModePicker.MODE_PANORAMA);
+
+        mShutterButton = (ShutterButton) findViewById(R.id.shutter_button);
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
+        mShutterButton.setOnShutterButtonListener(this);
+
+        mPanoLayout = findViewById(R.id.pano_layout);
+
+        mRotateDialog = new RotateDialogController(this, R.layout.rotate_dialog);
+
+        if (getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) {
+            Rotatable[] rotateLayout = {
+                    (Rotatable) findViewById(R.id.pano_pan_progress_bar_layout),
+                    (Rotatable) findViewById(R.id.pano_capture_too_fast_textview_layout),
+                    (Rotatable) findViewById(R.id.pano_review_saving_indication_layout),
+                    (Rotatable) findViewById(R.id.pano_saving_progress_bar_layout),
+                    (Rotatable) findViewById(R.id.pano_review_cancel_button_layout),
+                    (Rotatable) findViewById(R.id.pano_rotate_reviewarea),
+                    (Rotatable) mRotateDialog,
+                    (Rotatable) mCaptureIndicator,
+                    (Rotatable) mModePicker,
+                    (Rotatable) mThumbnailView};
+            for (Rotatable r : rotateLayout) {
+                r.setOrientation(270);
+            }
+        }
+    }
+
+    @Override
+    public void onShutterButtonClick() {
+        // If mSurfaceTexture == null then GL setup is not finished yet.
+        // No buttons can be pressed.
+        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
+        // Since this button will stay on the screen when capturing, we need to check the state
+        // right now.
+        switch (mCaptureState) {
+            case CAPTURE_STATE_VIEWFINDER:
+                mCameraSound.play(MediaActionSound.START_VIDEO_RECORDING);
+                startCapture();
+                break;
+            case CAPTURE_STATE_MOSAIC:
+                mCameraSound.play(MediaActionSound.STOP_VIDEO_RECORDING);
+                stopCapture(false);
+        }
+    }
+
+    @Override
+    public void onShutterButtonFocus(boolean pressed) {
+    }
+
+    public void reportProgress() {
+        mSavingProgressBar.reset();
+        mSavingProgressBar.setRightIncreasing(true);
+        Thread t = new Thread() {
+            @Override
+            public void run() {
+                while (mThreadRunning) {
+                    final int progress = mMosaicFrameProcessor.reportProgress(
+                            true, mCancelComputation);
+
+                    try {
+                        synchronized (mWaitObject) {
+                            mWaitObject.wait(50);
+                        }
+                    } catch (InterruptedException e) {
+                        throw new RuntimeException("Panorama reportProgress failed", e);
+                    }
+                    // Update the progress bar
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            mSavingProgressBar.setProgress(progress);
+                        }
+                    });
+                }
+            }
+        };
+        t.start();
+    }
+
+    private void initThumbnailButton() {
+        // Load the thumbnail from the disk.
+        if (mThumbnail == null) {
+            mThumbnail = Thumbnail.loadFrom(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
+        }
+        updateThumbnailButton();
+    }
+
+    private void updateThumbnailButton() {
+        // Update last image if URI is invalid and the storage is ready.
+        ContentResolver contentResolver = getContentResolver();
+        if ((mThumbnail == null || !Util.isUriValid(mThumbnail.getUri(), contentResolver))) {
+            mThumbnail = Thumbnail.getLastThumbnail(contentResolver);
+        }
+        if (mThumbnail != null) {
+            mThumbnailView.setBitmap(mThumbnail.getBitmap());
+        } else {
+            mThumbnailView.setBitmap(null);
+        }
+    }
+
+    private void saveThumbnailToFile() {
+        if (mThumbnail != null && !mThumbnail.fromFile()) {
+            mThumbnail.saveTo(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
+        }
+    }
+
+    public void saveHighResMosaic() {
+        runBackgroundThread(new Thread() {
+            @Override
+            public void run() {
+                mPartialWakeLock.acquire();
+                MosaicJpeg jpeg;
+                try {
+                    jpeg = generateFinalMosaic(true);
+                } finally {
+                    mPartialWakeLock.release();
+                }
+
+                if (jpeg == null) {  // Cancelled by user.
+                    mMainHandler.sendEmptyMessage(MSG_RESET_TO_PREVIEW);
+                } else if (!jpeg.isValid) {  // Error when generating mosaic.
+                    mMainHandler.sendEmptyMessage(MSG_GENERATE_FINAL_MOSAIC_ERROR);
+                } else {
+                    // The panorama image returned from the library is orientated based on the
+                    // natural orientation of a camera. We need to set an orientation for the image
+                    // in its EXIF header, so the image can be displayed correctly.
+                    // The orientation is calculated from compensating the
+                    // device orientation at capture and the camera orientation respective to
+                    // the natural orientation of the device.
+                    int orientation = (mDeviceOrientationAtCapture + mCameraOrientation) % 360;
+                    Uri uri = savePanorama(jpeg.data, jpeg.width, jpeg.height, orientation);
+                    if (uri != null) {
+                        // Create a thumbnail whose width or height is equal or bigger
+                        // than the screen's width or height.
+                        int widthRatio = (int) Math.ceil((double) jpeg.width
+                                / mPanoLayout.getWidth());
+                        int heightRatio = (int) Math.ceil((double) jpeg.height
+                                / mPanoLayout.getHeight());
+                        int inSampleSize = Integer.highestOneBit(
+                                Math.max(widthRatio, heightRatio));
+                        mThumbnail = Thumbnail.createThumbnail(
+                                jpeg.data, orientation, inSampleSize, uri);
+                        Util.broadcastNewPicture(PanoramaActivity.this, uri);
+                    }
+                    mMainHandler.sendMessage(
+                            mMainHandler.obtainMessage(MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL));
+                }
+            }
+        });
+        reportProgress();
+    }
+
+    private void runBackgroundThread(Thread thread) {
+        mThreadRunning = true;
+        thread.start();
+    }
+
+    private void onBackgroundThreadFinished() {
+        mThreadRunning = false;
+        mRotateDialog.dismissDialog();
+    }
+
+    private void cancelHighResComputation() {
+        mCancelComputation = true;
+        synchronized (mWaitObject) {
+            mWaitObject.notify();
+        }
+    }
+
+    @OnClickAttr
+    public void onCancelButtonClicked(View v) {
+        if (mPausing || mSurfaceTexture == null) return;
+        cancelHighResComputation();
+    }
+
+    @OnClickAttr
+    public void onThumbnailClicked(View v) {
+        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
+        showSharePopup();
+    }
+
+    private void showSharePopup() {
+        if (mThumbnail == null) return;
+        Uri uri = mThumbnail.getUri();
+        if (mSharePopup == null || !uri.equals(mSharePopup.getUri())) {
+            // The orientation compensation is set to 0 here because we only support landscape.
+            mSharePopup = new SharePopup(this, uri, mThumbnail.getBitmap(),
+                    mOrientationCompensation,
+                    findViewById(R.id.frame_layout));
+        }
+        mSharePopup.showAtLocation(mThumbnailView, Gravity.NO_GRAVITY, 0, 0);
+    }
+
+    private void reset() {
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+
+        mReviewLayout.setVisibility(View.GONE);
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
+        mPanoProgressBar.setVisibility(View.GONE);
+        mCaptureLayout.setVisibility(View.VISIBLE);
+        mMosaicFrameProcessor.reset();
+
+        mSurfaceTexture.setOnFrameAvailableListener(this);
+    }
+
+    private void resetToPreview() {
+        reset();
+        if (!mPausing) {
+           mMosaicView.onPause();
+           mMosaicView.onResume();
+           startCameraPreview();
+        }
+    }
+
+    private void showFinalMosaic(Bitmap bitmap) {
+        if (bitmap != null) {
+            mReview.setImageBitmap(bitmap);
+        }
+        mCaptureLayout.setVisibility(View.GONE);
+        mReviewLayout.setVisibility(View.VISIBLE);
+    }
+
+    private Uri savePanorama(byte[] jpegData, int width, int height, int orientation) {
+        if (jpegData != null) {
+            String filename = PanoUtil.createName(
+                    getResources().getString(R.string.pano_file_name_format), mTimeTaken);
+            Uri uri = Storage.addImage(getContentResolver(), filename, mTimeTaken, null,
+                    orientation, jpegData, width, height);
+            if (uri != null && orientation != 0) {
+                String filepath = Storage.generateFilepath(filename);
+                try {
+                    // Save the orientation in EXIF.
+                    ExifInterface exif = new ExifInterface(filepath);
+                    exif.setAttribute(ExifInterface.TAG_ORIENTATION,
+                            getExifOrientation(orientation));
+                    exif.saveAttributes();
+                } catch (IOException e) {
+                    Log.e(TAG, "cannot set exif data: " + filepath);
+                }
+            }
+            return uri;
+        }
+        return null;
+    }
+
+    private static String getExifOrientation(int orientation) {
+        switch (orientation) {
+            case 0:
+                return String.valueOf(ExifInterface.ORIENTATION_NORMAL);
+            case 90:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_90);
+            case 180:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_180);
+            case 270:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_270);
+            default:
+                throw new AssertionError("invalid: " + orientation);
+        }
+    }
+
+    private void clearMosaicFrameProcessorIfNeeded() {
+        if (!mPausing || mThreadRunning) return;
+        mMosaicFrameProcessor.clear();
+    }
+
+    private void initMosaicFrameProcessorIfNeeded() {
+        if (mPausing || mThreadRunning) return;
+        if (mMosaicFrameProcessor == null) {
+            // Start the activity for the first time.
+            mMosaicFrameProcessor = new MosaicFrameProcessor(
+                    mPreviewWidth, mPreviewHeight, getPreviewBufSize());
+        }
+        mMosaicFrameProcessor.initialize();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+
+        mPausing = true;
+        // Stop the capturing first.
+        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
+            stopCapture(true);
+            reset();
+        }
+        if (mSharePopup != null) mSharePopup.dismiss();
+
+        saveThumbnailToFile();
+
+        releaseCamera();
+        mMosaicView.onPause();
+        clearMosaicFrameProcessorIfNeeded();
+        mOrientationEventListener.disable();
+        resetScreenOn();
+        mCameraSound.release();
+        System.gc();
+    }
+
+    @Override
+    protected void doOnResume() {
+        mPausing = false;
+        mOrientationEventListener.enable();
+
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+        try {
+            setupCamera();
+
+            // Camera must be initialized before MosaicFrameProcessor is initialized.
+            // The preview size has to be decided by camera device.
+            initMosaicFrameProcessorIfNeeded();
+            mMosaicView.onResume();
+
+            initThumbnailButton();
+            keepScreenOnAwhile();
+        } catch (CameraHardwareException e) {
+            Util.showErrorAndFinish(this, R.string.cannot_connect_camera);
+            return;
+        } catch (CameraDisabledException e) {
+            Util.showErrorAndFinish(this, R.string.camera_disabled);
+            return;
+        }
+        // Dismiss open menu if exists.
+        PopupManager.getInstance(this).notifyShowPopup(null);
+    }
+
+    /**
+     * Generate the final mosaic image.
+     *
+     * @param highRes flag to indicate whether we want to get a high-res version.
+     * @return a MosaicJpeg with its isValid flag set to true if successful; null if the generation
+     *         process is cancelled; and a MosaicJpeg with its isValid flag set to false if there
+     *         is an error in generating the final mosaic.
+     */
+    public MosaicJpeg generateFinalMosaic(boolean highRes) {
+        int mosaicReturnCode = mMosaicFrameProcessor.createMosaic(highRes);
+        if (mosaicReturnCode == Mosaic.MOSAIC_RET_CANCELLED) {
+            return null;
+        } else if (mosaicReturnCode == Mosaic.MOSAIC_RET_ERROR) {
+            return new MosaicJpeg();
+        }
+
+        byte[] imageData = mMosaicFrameProcessor.getFinalMosaicNV21();
+        if (imageData == null) {
+            Log.e(TAG, "getFinalMosaicNV21() returned null.");
+            return new MosaicJpeg();
+        }
+
+        int len = imageData.length - 8;
+        int width = (imageData[len + 0] << 24) + ((imageData[len + 1] & 0xFF) << 16)
+                + ((imageData[len + 2] & 0xFF) << 8) + (imageData[len + 3] & 0xFF);
+        int height = (imageData[len + 4] << 24) + ((imageData[len + 5] & 0xFF) << 16)
+                + ((imageData[len + 6] & 0xFF) << 8) + (imageData[len + 7] & 0xFF);
+        Log.v(TAG, "ImLength = " + (len) + ", W = " + width + ", H = " + height);
+
+        if (width <= 0 || height <= 0) {
+            // TODO: pop up a error meesage indicating that the final result is not generated.
+            Log.e(TAG, "width|height <= 0!!, len = " + (len) + ", W = " + width + ", H = " +
+                    height);
+            return new MosaicJpeg();
+        }
+
+        YuvImage yuvimage = new YuvImage(imageData, ImageFormat.NV21, width, height, null);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        yuvimage.compressToJpeg(new Rect(0, 0, width, height), 100, out);
+        try {
+            out.close();
+        } catch (Exception e) {
+            Log.e(TAG, "Exception in storing final mosaic", e);
+            return new MosaicJpeg();
+        }
+        return new MosaicJpeg(out.toByteArray(), width, height);
+    }
+
+    private void setPreviewTexture(SurfaceTexture surface) {
+        try {
+            mCameraDevice.setPreviewTexture(surface);
+        } catch (Throwable ex) {
+            releaseCamera();
+            throw new RuntimeException("setPreviewTexture failed", ex);
+        }
+    }
+
+    private void startCameraPreview() {
+        // If we're previewing already, stop the preview first (this will blank
+        // the screen).
+        if (mCameraState != PREVIEW_STOPPED) stopCameraPreview();
+
+        // Set the display orientation to 0, so that the underlying mosaic library
+        // can always get undistorted mPreviewWidth x mPreviewHeight image data
+        // from SurfaceTexture.
+        mCameraDevice.setDisplayOrientation(0);
+
+        setPreviewTexture(mSurfaceTexture);
+
+        try {
+            Log.v(TAG, "startPreview");
+            mCameraDevice.startPreview();
+        } catch (Throwable ex) {
+            releaseCamera();
+            throw new RuntimeException("startPreview failed", ex);
+        }
+        mCameraState = PREVIEW_ACTIVE;
+    }
+
+    private void stopCameraPreview() {
+        if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
+            Log.v(TAG, "stopPreview");
+            mCameraDevice.stopPreview();
+        }
+        mCameraState = PREVIEW_STOPPED;
+    }
+
+    @Override
+    public void onUserInteraction() {
+        super.onUserInteraction();
+        if (mCaptureState != CAPTURE_STATE_MOSAIC) keepScreenOnAwhile();
+    }
+
+    @Override
+    public void onBackPressed() {
+        // If panorama is generating low res or high res mosaic, ignore back
+        // key. So the activity will not be destroyed.
+        if (mThreadRunning) return;
+        super.onBackPressed();
+    }
+
+    private void resetScreenOn() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+
+    private void keepScreenOnAwhile() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+        mMainHandler.sendEmptyMessageDelayed(MSG_CLEAR_SCREEN_DELAY, SCREEN_DELAY);
+    }
+
+    private void keepScreenOn() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+}
diff --git a/src/com/android/camera/panorama/Mosaic.java b/src/com/android/camera/panorama/Mosaic.java
deleted file mode 100644
index 90bf2ad..0000000
--- a/src/com/android/camera/panorama/Mosaic.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-/**
- * The Java interface to JNI calls regarding mosaic stitching.
- *
- * A high-level usage is:
- *
- * Mosaic mosaic = new Mosaic();
- * mosaic.setSourceImageDimensions(width, height);
- * mosaic.reset(blendType);
- *
- * while ((pixels = hasNextImage()) != null) {
- *    mosaic.setSourceImage(pixels);
- * }
- *
- * mosaic.createMosaic(highRes);
- * byte[] result = mosaic.getFinalMosaic();
- *
- */
-public class Mosaic {
-    /**
-     * In this mode, the images are stitched together in the same spatial arrangement as acquired
-     * i.e. if the user follows a curvy trajectory, the image boundary of the resulting mosaic will
-     * be curved in the same manner. This mode is useful if the user wants to capture a mosaic as
-     * if "painting" the scene using the smart-phone device and does not want any corrective warps
-     * to distort the captured images.
-     */
-    public static final int BLENDTYPE_FULL = 0;
-
-    /**
-     * This mode is the same as BLENDTYPE_FULL except that the resulting mosaic is rotated
-     * to balance the first and last images to be approximately at the same vertical offset in the
-     * output mosaic. This is useful when acquiring a mosaic by a typical panning-like motion to
-     * remove a one-sided curve in the mosaic (typically due to the camera not staying horizontal
-     * during the video capture) and convert it to a more symmetrical "smiley-face" like output.
-     */
-    public static final int BLENDTYPE_PAN = 1;
-
-    /**
-     * This mode compensates for typical "smiley-face" like output in longer mosaics and creates
-     * a rectangular mosaic with minimal black borders (by unwrapping the mosaic onto an imaginary
-     * cylinder). If the user follows a curved trajectory (instead of a perfect panning trajectory),
-     * the resulting mosaic here may suffer from some image distortions in trying to map the
-     * trajectory to a cylinder.
-     */
-    public static final int BLENDTYPE_CYLINDERPAN = 2;
-
-    /**
-     * This mode is basically BLENDTYPE_CYLINDERPAN plus doing a rectangle cropping before returning
-     * the mosaic. The mode is useful for making the resulting mosaic have a rectangle shape.
-     */
-    public static final int BLENDTYPE_HORIZONTAL =3;
-
-    /**
-     * This strip type will use the default thin strips where the strips are
-     * spaced according to the image capture rate.
-     */
-    public static final int STRIPTYPE_THIN = 0;
-
-    /**
-     * This strip type will use wider strips for blending. The strip separation
-     * is controlled by a threshold on the native side. Since the strips are
-     * wider, there is an additional cross-fade blending step to make the seam
-     * boundaries smoother. Since this mode uses lesser image frames, it is
-     * computationally more efficient than the thin strip mode.
-     */
-    public static final int STRIPTYPE_WIDE = 1;
-
-    /**
-     * Return flags returned by createMosaic() are one of the following.
-     */
-    public static final int MOSAIC_RET_OK = 1;
-    public static final int MOSAIC_RET_ERROR = -1;
-    public static final int MOSAIC_RET_CANCELLED = -2;
-    public static final int MOSAIC_RET_LOW_TEXTURE = -3;
-    public static final int MOSAIC_RET_FEW_INLIERS = 2;
-
-
-    static {
-        System.loadLibrary("jni_legacymosaic");
-    }
-
-    /**
-     * Allocate memory for the image frames at the given resolution.
-     *
-     * @param width width of the input frames in pixels
-     * @param height height of the input frames in pixels
-     */
-    public native void allocateMosaicMemory(int width, int height);
-
-    /**
-     * Free memory allocated by allocateMosaicMemory.
-     *
-     */
-    public native void freeMosaicMemory();
-
-    /**
-     * Pass the input image frame to the native layer. Each time the a new
-     * source image t is set, the transformation matrix from the first source
-     * image to t is computed and returned.
-     *
-     * @param pixels source image of NV21 format.
-     * @return Float array of length 11; first 9 entries correspond to the 3x3
-     *         transformation matrix between the first frame and the passed frame;
-     *         the 10th entry is the number of the passed frame, where the counting
-     *         starts from 1; and the 11th entry is the returning code, whose value
-     *         is one of those MOSAIC_RET_* returning flags defined above.
-     */
-    public native float[] setSourceImage(byte[] pixels);
-
-    /**
-     * This is an alternative to the setSourceImage function above. This should
-     * be called when the image data is already on the native side in a fixed
-     * byte array. In implementation, this array is filled by the GL thread
-     * using glReadPixels directly from GPU memory (where it is accessed by
-     * an associated SurfaceTexture).
-     *
-     * @return Float array of length 11; first 9 entries correspond to the 3x3
-     *         transformation matrix between the first frame and the passed frame;
-     *         the 10th entry is the number of the passed frame, where the counting
-     *         starts from 1; and the 11th entry is the returning code, whose value
-     *         is one of those MOSAIC_RET_* returning flags defined above.
-     */
-    public native float[] setSourceImageFromGPU();
-
-    /**
-     * Set the type of blending.
-     *
-     * @param type the blending type defined in the class. {BLENDTYPE_FULL,
-     *        BLENDTYPE_PAN, BLENDTYPE_CYLINDERPAN, BLENDTYPE_HORIZONTAL}
-     */
-    public native void setBlendingType(int type);
-
-    /**
-     * Set the type of strips to use for blending.
-     * @param type the blending strip type to use {STRIPTYPE_THIN,
-     * STRIPTYPE_WIDE}.
-     */
-    public native void setStripType(int type);
-
-    /**
-     * Tell the native layer to create the final mosaic after all the input frame
-     * data have been collected.
-     * The case of generating high-resolution mosaic may take dozens of seconds to finish.
-     *
-     * @param value True means generating a high-resolution mosaic -
-     *        which is based on the original images set in setSourceImage().
-     *        False means generating a low-resolution version -
-     *        which is based on 1/4 downscaled images from the original images.
-     * @return Returns a status code suggesting if the mosaic building was
-     *        successful, in error, or was cancelled by the user.
-     */
-    public native int createMosaic(boolean value);
-
-    /**
-     * Get the data for the created mosaic.
-     *
-     * @return Returns an integer array which contains the final mosaic in the ARGB_8888 format.
-     *         The first MosaicWidth*MosaicHeight values contain the image data, followed by 2
-     *         integers corresponding to the values MosaicWidth and MosaicHeight respectively.
-     */
-    public native int[] getFinalMosaic();
-
-    /**
-     * Get the data for the created mosaic.
-     *
-     * @return Returns a byte array which contains the final mosaic in the NV21 format.
-     *         The first MosaicWidth*MosaicHeight*1.5 values contain the image data, followed by
-     *         8 bytes which pack the MosaicWidth and MosaicHeight integers into 4 bytes each
-     *         respectively.
-     */
-    public native byte[] getFinalMosaicNV21();
-
-    /**
-     * Reset the state of the frame arrays which maintain the captured frame data.
-     * Also re-initializes the native mosaic object to make it ready for capturing a new mosaic.
-     */
-    public native void reset();
-
-    /**
-     * Get the progress status of the mosaic computation process.
-     * @param hires Boolean flag to select whether to report progress of the
-     *              low-res or high-res mosaicer.
-     * @param cancelComputation Boolean flag to allow cancelling the
-     *              mosaic computation when needed from the GUI end.
-     * @return Returns a number from 0-100 where 50 denotes that the mosaic
-     *          computation is 50% done.
-     */
-    public native int reportProgress(boolean hires, boolean cancelComputation);
-}
diff --git a/src/com/android/camera/panorama/MosaicFrameProcessor.java b/src/com/android/camera/panorama/MosaicFrameProcessor.java
deleted file mode 100644
index 6c70b19..0000000
--- a/src/com/android/camera/panorama/MosaicFrameProcessor.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import android.util.Log;
-
-/**
- * Class to handle the processing of each frame by Mosaicer.
- */
-public class MosaicFrameProcessor {
-    private static final boolean LOGV = true;
-    private static final String TAG = "MosaicFrameProcessor";
-    private static final int NUM_FRAMES_IN_BUFFER = 2;
-    private static final int MAX_NUMBER_OF_FRAMES = 100;
-    private static final int MOSAIC_RET_CODE_INDEX = 10;
-    private static final int FRAME_COUNT_INDEX = 9;
-    private static final int X_COORD_INDEX = 2;
-    private static final int Y_COORD_INDEX = 5;
-    private static final int HR_TO_LR_DOWNSAMPLE_FACTOR = 4;
-    private static final int WINDOW_SIZE = 3;
-
-    private Mosaic mMosaicer;
-    private boolean mIsMosaicMemoryAllocated = false;
-    private final long [] mFrameTimestamp = new long[NUM_FRAMES_IN_BUFFER];
-    private float mTranslationLastX;
-    private float mTranslationLastY;
-
-    private int mFillIn = 0;
-    private int mTotalFrameCount = 0;
-    private long mLastProcessedFrameTimestamp = 0;
-    private int mLastProcessFrameIdx = -1;
-    private int mCurrProcessFrameIdx = -1;
-
-    // Panning rate is in unit of percentage of image content translation / second.
-    // Use the moving average to calculate the panning rate.
-    private float mPanningRateX;
-    private float mPanningRateY;
-
-    private float[] mDeltaX = new float[WINDOW_SIZE];
-    private float[] mDeltaY = new float[WINDOW_SIZE];
-    private float[] mDeltaTime = new float[WINDOW_SIZE];
-    private int mOldestIdx = 0;
-    private float mTotalTranslationX = 0f;
-    private float mTotalTranslationY = 0f;
-    private float mTotalDeltaTime = 0f;
-
-    private ProgressListener mProgressListener;
-
-    private int mPreviewWidth;
-    private int mPreviewHeight;
-    private int mPreviewBufferSize;
-
-    public interface ProgressListener {
-        public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
-                float progressX, float progressY);
-    }
-
-    public MosaicFrameProcessor(int previewWidth, int previewHeight, int bufSize) {
-        mMosaicer = new Mosaic();
-        mPreviewWidth = previewWidth;
-        mPreviewHeight = previewHeight;
-        mPreviewBufferSize = bufSize;
-    }
-
-    public void setProgressListener(ProgressListener listener) {
-        mProgressListener = listener;
-    }
-
-    public int reportProgress(boolean hires, boolean cancel) {
-        return mMosaicer.reportProgress(hires, cancel);
-    }
-
-    public void initialize() {
-        setupMosaicer(mPreviewWidth, mPreviewHeight, mPreviewBufferSize);
-        setStripType(Mosaic.STRIPTYPE_WIDE);
-        reset();
-    }
-
-    public void clear() {
-        if (mIsMosaicMemoryAllocated) {
-            mIsMosaicMemoryAllocated = false;
-            mMosaicer.freeMosaicMemory();
-        }
-    }
-
-    public void setStripType(int type) {
-        mMosaicer.setStripType(type);
-    }
-
-    private void setupMosaicer(int previewWidth, int previewHeight, int bufSize) {
-        Log.v(TAG, "setupMosaicer w, h=" + previewWidth + ',' + previewHeight + ',' + bufSize);
-        mMosaicer.allocateMosaicMemory(previewWidth, previewHeight);
-        mIsMosaicMemoryAllocated = true;
-
-        mFillIn = 0;
-        if  (mMosaicer != null) {
-            mMosaicer.reset();
-        }
-    }
-
-    public void reset() {
-        // reset() can be called even if MosaicFrameProcessor is not initialized.
-        // Only counters will be changed.
-        mTotalFrameCount = 0;
-        mFillIn = 0;
-        mLastProcessedFrameTimestamp = 0;
-        mTotalTranslationX = 0;
-        mTranslationLastX = 0;
-        mTotalTranslationY = 0;
-        mTranslationLastY = 0;
-        mTotalDeltaTime = 0;
-        mPanningRateX = 0;
-        mPanningRateY = 0;
-        mLastProcessFrameIdx = -1;
-        mCurrProcessFrameIdx = -1;
-        for (int i = 0; i < WINDOW_SIZE; ++i) {
-            mDeltaX[i] = 0f;
-            mDeltaY[i] = 0f;
-            mDeltaTime[i] = 0f;
-        }
-        mMosaicer.reset();
-    }
-
-    public int createMosaic(boolean highRes) {
-        return mMosaicer.createMosaic(highRes);
-    }
-
-    public byte[] getFinalMosaicNV21() {
-        return mMosaicer.getFinalMosaicNV21();
-    }
-
-    // Processes the last filled image frame through the mosaicer and
-    // updates the UI to show progress.
-    // When done, processes and displays the final mosaic.
-    public void processFrame() {
-        if (!mIsMosaicMemoryAllocated) {
-            // clear() is called and buffers are cleared, stop computation.
-            // This can happen when the onPause() is called in the activity, but still some frames
-            // are not processed yet and thus the callback may be invoked.
-            return;
-        }
-        long t1 = System.currentTimeMillis();
-        mFrameTimestamp[mFillIn] = t1;
-
-        mCurrProcessFrameIdx = mFillIn;
-        mFillIn = ((mFillIn + 1) % NUM_FRAMES_IN_BUFFER);
-
-        // Check that we are trying to process a frame different from the
-        // last one processed (useful if this class was running asynchronously)
-        if (mCurrProcessFrameIdx != mLastProcessFrameIdx) {
-            mLastProcessFrameIdx = mCurrProcessFrameIdx;
-
-            // Access the timestamp associated with it...
-            long timestamp = mFrameTimestamp[mCurrProcessFrameIdx];
-
-            // TODO: make the termination condition regarding reaching
-            // MAX_NUMBER_OF_FRAMES solely determined in the library.
-            if (mTotalFrameCount < MAX_NUMBER_OF_FRAMES) {
-                // If we are still collecting new frames for the current mosaic,
-                // process the new frame.
-                calculateTranslationRate(timestamp);
-
-                // Publish progress of the ongoing processing
-                if (mProgressListener != null) {
-                    mProgressListener.onProgress(false, mPanningRateX, mPanningRateY,
-                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
-                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
-                }
-            } else {
-                if (mProgressListener != null) {
-                    mProgressListener.onProgress(true, mPanningRateX, mPanningRateY,
-                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
-                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
-                }
-            }
-        }
-    }
-
-    public void calculateTranslationRate(long now) {
-        float[] frameData = mMosaicer.setSourceImageFromGPU();
-        int ret_code = (int) frameData[MOSAIC_RET_CODE_INDEX];
-        mTotalFrameCount  = (int) frameData[FRAME_COUNT_INDEX];
-        float translationCurrX = frameData[X_COORD_INDEX];
-        float translationCurrY = frameData[Y_COORD_INDEX];
-
-        if (mLastProcessedFrameTimestamp == 0f) {
-            // First time: no need to update delta values.
-            mTranslationLastX = translationCurrX;
-            mTranslationLastY = translationCurrY;
-            mLastProcessedFrameTimestamp = now;
-            return;
-        }
-
-        // Moving average: remove the oldest translation/deltaTime and
-        // add the newest translation/deltaTime in
-        int idx = mOldestIdx;
-        mTotalTranslationX -= mDeltaX[idx];
-        mTotalTranslationY -= mDeltaY[idx];
-        mTotalDeltaTime -= mDeltaTime[idx];
-        mDeltaX[idx] = Math.abs(translationCurrX - mTranslationLastX);
-        mDeltaY[idx] = Math.abs(translationCurrY - mTranslationLastY);
-        mDeltaTime[idx] = (now - mLastProcessedFrameTimestamp) / 1000.0f;
-        mTotalTranslationX += mDeltaX[idx];
-        mTotalTranslationY += mDeltaY[idx];
-        mTotalDeltaTime += mDeltaTime[idx];
-
-        // The panning rate is measured as the rate of the translation percentage in
-        // image width/height. Take the horizontal panning rate for example, the image width
-        // used in finding the translation is (PreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR).
-        // To get the horizontal translation percentage, the horizontal translation,
-        // (translationCurrX - mTranslationLastX), is divided by the
-        // image width. We then get the rate by dividing the translation percentage with deltaTime.
-        mPanningRateX = mTotalTranslationX /
-                (mPreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
-        mPanningRateY = mTotalTranslationY /
-                (mPreviewHeight / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
-
-        mTranslationLastX = translationCurrX;
-        mTranslationLastY = translationCurrY;
-        mLastProcessedFrameTimestamp = now;
-        mOldestIdx = (mOldestIdx + 1) % WINDOW_SIZE;
-    }
-}
diff --git a/src/com/android/camera/panorama/MosaicRenderer.java b/src/com/android/camera/panorama/MosaicRenderer.java
deleted file mode 100644
index f4e9abc..0000000
--- a/src/com/android/camera/panorama/MosaicRenderer.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-/**
- * The Java interface to JNI calls regarding mosaic preview rendering.
- *
- */
-public class MosaicRenderer
-{
-     static
-     {
-         System.loadLibrary("jni_legacymosaic");
-     }
-
-     /**
-      * Function to be called in onSurfaceCreated() to initialize
-      * the GL context, load and link the shaders and create the
-      * program. Returns a texture ID to be used for SurfaceTexture.
-      *
-      * @return textureID the texture ID of the newly generated texture to
-      *          be assigned to the SurfaceTexture object.
-      */
-     public static native int init();
-
-     /**
-      * Pass the drawing surface's width and height to initialize the
-      * renderer viewports and FBO dimensions.
-      *
-      * @param width width of the drawing surface in pixels.
-      * @param height height of the drawing surface in pixels.
-      * @param isLandscapeOrientation is the orientation of the activity layout in landscape.
-      */
-     public static native void reset(int width, int height, boolean isLandscapeOrientation);
-
-     /**
-      * Calling this function will render the SurfaceTexture to a new 2D texture
-      * using the provided STMatrix.
-      *
-      * @param stMatrix texture coordinate transform matrix obtained from the
-      *        Surface texture
-      */
-     public static native void preprocess(float[] stMatrix);
-
-     /**
-      * This function calls glReadPixels to transfer both the low-res and high-res
-      * data from the GPU memory to the CPU memory for further processing by the
-      * mosaicing library.
-      */
-     public static native void transferGPUtoCPU();
-
-     /**
-      * Function to be called in onDrawFrame() to update the screen with
-      * the new frame data.
-      */
-     public static native void step();
-
-     /**
-      * Call this function when a new low-res frame has been processed by
-      * the mosaicing library. This will tell the renderer library to
-      * update its texture and warping transformation. Any calls to step()
-      * after this call will use the new image frame and transformation data.
-      */
-     public static native void ready();
-
-     /**
-      * This function allows toggling between showing the input image data
-      * (without applying any warp) and the warped image data. For running
-      * the renderer as a viewfinder, we set the flag to false. To see the
-      * preview mosaic, we set the flag to true.
-      *
-      * @param flag boolean flag to set the warping to true or false.
-      */
-     public static native void setWarping(boolean flag);
-}
diff --git a/src/com/android/camera/panorama/MosaicRendererSurfaceView.java b/src/com/android/camera/panorama/MosaicRendererSurfaceView.java
deleted file mode 100644
index b2acfde..0000000
--- a/src/com/android/camera/panorama/MosaicRendererSurfaceView.java
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.pm.ActivityInfo;
-import android.graphics.PixelFormat;
-import android.opengl.GLSurfaceView;
-import android.os.ConditionVariable;
-import android.util.AttributeSet;
-import android.util.Log;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-
-public class MosaicRendererSurfaceView extends GLSurfaceView {
-    private static final String TAG = "MosaicRendererSurfaceView";
-    private static final boolean DEBUG = false;
-    private MosaicRendererSurfaceViewRenderer mRenderer;
-    private ConditionVariable mPreviewFrameReadyForProcessing;
-    private boolean mIsLandscapeOrientation = true;
-
-    public MosaicRendererSurfaceView(Context context) {
-        super(context);
-        initialize(context, false, 0, 0);
-    }
-
-    public MosaicRendererSurfaceView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initialize(context, false, 0, 0);
-    }
-
-    public MosaicRendererSurfaceView(Context context, boolean translucent,
-            int depth, int stencil) {
-        super(context);
-        initialize(context, translucent, depth, stencil);
-    }
-
-    private void initialize(Context context, boolean translucent, int depth, int stencil) {
-        getDisplayOrientation(context);
-        init(translucent, depth, stencil);
-        setZOrderMediaOverlay(true);
-    }
-
-    private void getDisplayOrientation(Context context) {
-        Activity activity = (PanoramaActivity) context;
-        mIsLandscapeOrientation = (activity.getRequestedOrientation()
-                == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE );
-    }
-
-    private void init(boolean translucent, int depth, int stencil) {
-
-        /* By default, GLSurfaceView() creates a RGB_565 opaque surface.
-         * If we want a translucent one, we should change the surface's
-         * format here, using PixelFormat.TRANSLUCENT for GL Surfaces
-         * is interpreted as any 32-bit surface with alpha by SurfaceFlinger.
-         */
-        if (translucent) {
-            this.getHolder().setFormat(PixelFormat.TRANSLUCENT);
-        }
-
-        /* Setup the context factory for 2.0 rendering.
-         * See ContextFactory class definition below
-         */
-        setEGLContextFactory(new ContextFactory());
-
-        /* We need to choose an EGLConfig that matches the format of
-         * our surface exactly. This is going to be done in our
-         * custom config chooser. See ConfigChooser class definition
-         * below.
-         */
-        setEGLConfigChooser(
-            translucent ? new ConfigChooser(8, 8, 8, 8, depth, stencil) :
-            new ConfigChooser(5, 6, 5, 0, depth, stencil));
-
-        /* Set the renderer responsible for frame rendering */
-        mRenderer = new MosaicRendererSurfaceViewRenderer(mIsLandscapeOrientation);
-        setRenderer(mRenderer);
-        setRenderMode(RENDERMODE_WHEN_DIRTY);
-        mPreviewFrameReadyForProcessing = new ConditionVariable();
-    }
-
-    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
-        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
-            Log.w(TAG, "creating OpenGL ES 2.0 context");
-            checkEglError("Before eglCreateContext", egl);
-            int[] attribList = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
-            EGLContext context = egl.eglCreateContext(
-                display, eglConfig, EGL10.EGL_NO_CONTEXT, attribList);
-            checkEglError("After eglCreateContext", egl);
-            return context;
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
-            egl.eglDestroyContext(display, context);
-        }
-    }
-
-    private static void checkEglError(String prompt, EGL10 egl) {
-        int error;
-        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
-            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
-        }
-    }
-
-    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
-
-        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
-            mRedSize = r;
-            mGreenSize = g;
-            mBlueSize = b;
-            mAlphaSize = a;
-            mDepthSize = depth;
-            mStencilSize = stencil;
-        }
-
-        /* This EGL config specification is used to specify 2.0 rendering.
-         * We use a minimum size of 4 bits for red/green/blue, but will
-         * perform actual matching in chooseConfig() below.
-         */
-        private static final int EGL_OPENGL_ES2_BIT = 4;
-        private static final int[] CONFIG_ATTRIBUTES =
-        {
-            EGL10.EGL_RED_SIZE, 4,
-            EGL10.EGL_GREEN_SIZE, 4,
-            EGL10.EGL_BLUE_SIZE, 4,
-            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL10.EGL_NONE
-        };
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-
-            /* Get the number of minimally matching EGL configurations
-             */
-            int[] numConfig = new int[1];
-            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, null, 0, numConfig);
-
-            int numConfigs = numConfig[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException("No configs match configSpec");
-            }
-
-            /* Allocate then read the array of minimally matching EGL configs
-             */
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, configs, numConfigs, numConfig);
-
-            if (DEBUG) {
-                 printConfigs(egl, display, configs);
-            }
-            /* Now return the "best" one
-             */
-            return chooseConfig(egl, display, configs);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            for (EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-
-                // We need at least mDepthSize and mStencilSize bits
-                if (d < mDepthSize || s < mStencilSize)
-                    continue;
-
-                // We want an *exact* match for red/green/blue/alpha
-                int r = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_RED_SIZE, 0);
-                int g = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_GREEN_SIZE, 0);
-                int b = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_BLUE_SIZE, 0);
-                int a = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_ALPHA_SIZE, 0);
-
-                if (r == mRedSize && g == mGreenSize && b == mBlueSize && a == mAlphaSize)
-                    return config;
-            }
-            return null;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private void printConfigs(EGL10 egl, EGLDisplay display,
-            EGLConfig[] configs) {
-            int numConfigs = configs.length;
-            Log.w(TAG, String.format("%d configurations", numConfigs));
-            for (int i = 0; i < numConfigs; i++) {
-                Log.w(TAG, String.format("Configuration %d:\n", i));
-                printConfig(egl, display, configs[i]);
-            }
-        }
-
-        private void printConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig config) {
-            int[] attributes = {
-                    EGL10.EGL_BUFFER_SIZE,
-                    EGL10.EGL_ALPHA_SIZE,
-                    EGL10.EGL_BLUE_SIZE,
-                    EGL10.EGL_GREEN_SIZE,
-                    EGL10.EGL_RED_SIZE,
-                    EGL10.EGL_DEPTH_SIZE,
-                    EGL10.EGL_STENCIL_SIZE,
-                    EGL10.EGL_CONFIG_CAVEAT,
-                    EGL10.EGL_CONFIG_ID,
-                    EGL10.EGL_LEVEL,
-                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
-                    EGL10.EGL_MAX_PBUFFER_PIXELS,
-                    EGL10.EGL_MAX_PBUFFER_WIDTH,
-                    EGL10.EGL_NATIVE_RENDERABLE,
-                    EGL10.EGL_NATIVE_VISUAL_ID,
-                    EGL10.EGL_NATIVE_VISUAL_TYPE,
-                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
-                    EGL10.EGL_SAMPLES,
-                    EGL10.EGL_SAMPLE_BUFFERS,
-                    EGL10.EGL_SURFACE_TYPE,
-                    EGL10.EGL_TRANSPARENT_TYPE,
-                    EGL10.EGL_TRANSPARENT_RED_VALUE,
-                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
-                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
-                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
-                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
-                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
-                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
-                    EGL10.EGL_LUMINANCE_SIZE,
-                    EGL10.EGL_ALPHA_MASK_SIZE,
-                    EGL10.EGL_COLOR_BUFFER_TYPE,
-                    EGL10.EGL_RENDERABLE_TYPE,
-                    0x3042 // EGL10.EGL_CONFORMANT
-            };
-            String[] names = {
-                    "EGL_BUFFER_SIZE",
-                    "EGL_ALPHA_SIZE",
-                    "EGL_BLUE_SIZE",
-                    "EGL_GREEN_SIZE",
-                    "EGL_RED_SIZE",
-                    "EGL_DEPTH_SIZE",
-                    "EGL_STENCIL_SIZE",
-                    "EGL_CONFIG_CAVEAT",
-                    "EGL_CONFIG_ID",
-                    "EGL_LEVEL",
-                    "EGL_MAX_PBUFFER_HEIGHT",
-                    "EGL_MAX_PBUFFER_PIXELS",
-                    "EGL_MAX_PBUFFER_WIDTH",
-                    "EGL_NATIVE_RENDERABLE",
-                    "EGL_NATIVE_VISUAL_ID",
-                    "EGL_NATIVE_VISUAL_TYPE",
-                    "EGL_PRESERVED_RESOURCES",
-                    "EGL_SAMPLES",
-                    "EGL_SAMPLE_BUFFERS",
-                    "EGL_SURFACE_TYPE",
-                    "EGL_TRANSPARENT_TYPE",
-                    "EGL_TRANSPARENT_RED_VALUE",
-                    "EGL_TRANSPARENT_GREEN_VALUE",
-                    "EGL_TRANSPARENT_BLUE_VALUE",
-                    "EGL_BIND_TO_TEXTURE_RGB",
-                    "EGL_BIND_TO_TEXTURE_RGBA",
-                    "EGL_MIN_SWAP_INTERVAL",
-                    "EGL_MAX_SWAP_INTERVAL",
-                    "EGL_LUMINANCE_SIZE",
-                    "EGL_ALPHA_MASK_SIZE",
-                    "EGL_COLOR_BUFFER_TYPE",
-                    "EGL_RENDERABLE_TYPE",
-                    "EGL_CONFORMANT"
-            };
-            int[] value = new int[1];
-            for (int i = 0; i < attributes.length; i++) {
-                int attribute = attributes[i];
-                String name = names[i];
-                if (egl.eglGetConfigAttrib(display, config, attribute, value)) {
-                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
-                } else {
-                    // Log.w(TAG, String.format("  %s: failed\n", name));
-                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
-                }
-            }
-        }
-
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        private int[] mValue = new int[1];
-    }
-
-    public void lockPreviewReadyFlag() {
-        mPreviewFrameReadyForProcessing.close();
-    }
-
-    private void unlockPreviewReadyFlag() {
-        mPreviewFrameReadyForProcessing.open();
-    }
-
-    public void waitUntilPreviewReady() {
-        mPreviewFrameReadyForProcessing.block();
-    }
-
-    public void setReady() {
-        queueEvent(new Runnable() {
-
-            @Override
-            public void run() {
-                mRenderer.setReady();
-            }
-        });
-    }
-
-    public void preprocess(final float[] transformMatrix) {
-        queueEvent(new Runnable() {
-
-            @Override
-            public void run() {
-                mRenderer.preprocess(transformMatrix);
-            }
-        });
-    }
-
-    public void transferGPUtoCPU() {
-        queueEvent(new Runnable() {
-
-            @Override
-            public void run() {
-                mRenderer.transferGPUtoCPU();
-                unlockPreviewReadyFlag();
-            }
-        });
-    }
-
-    public void setWarping(final boolean flag) {
-        queueEvent(new Runnable() {
-
-            @Override
-            public void run() {
-                mRenderer.setWarping(flag);
-            }
-        });
-    }
-
-    public MosaicRendererSurfaceViewRenderer getRenderer() {
-        return mRenderer;
-    }
-
-}
diff --git a/src/com/android/camera/panorama/MosaicRendererSurfaceViewRenderer.java b/src/com/android/camera/panorama/MosaicRendererSurfaceViewRenderer.java
deleted file mode 100755
index 3089972..0000000
--- a/src/com/android/camera/panorama/MosaicRendererSurfaceViewRenderer.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import android.opengl.GLSurfaceView;
-import android.util.Log;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-public class MosaicRendererSurfaceViewRenderer implements GLSurfaceView.Renderer
-{
-    private static final String TAG = "MosaicRendererSurfaceViewRenderer";
-    private boolean mIsLandscapeOrientation;
-
-    private MosaicSurfaceCreateListener mSurfaceCreateListener;
-
-    public MosaicRendererSurfaceViewRenderer(boolean isLandscapeOrientation) {
-        mIsLandscapeOrientation = isLandscapeOrientation;
-    }
-
-    /** A callback to be called when the surface is created */
-    public interface MosaicSurfaceCreateListener {
-        public void onMosaicSurfaceCreated(final int surface);
-        public void onMosaicSurfaceChanged();
-    }
-
-    @Override
-    public void onDrawFrame(GL10 gl) {
-        MosaicRenderer.step();
-    }
-
-    @Override
-    public void onSurfaceChanged(GL10 gl, int width, int height) {
-        MosaicRenderer.reset(width, height, mIsLandscapeOrientation);
-        Log.i(TAG, "Renderer: onSurfaceChanged");
-        if (mSurfaceCreateListener != null) {
-            mSurfaceCreateListener.onMosaicSurfaceChanged();
-        }
-    }
-
-    @Override
-    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-        Log.i(TAG, "onSurfaceCreated");
-        if (mSurfaceCreateListener != null) {
-            mSurfaceCreateListener.onMosaicSurfaceCreated(MosaicRenderer.init());
-        }
-    }
-
-    public void setMosaicSurfaceCreateListener(MosaicSurfaceCreateListener listener) {
-        mSurfaceCreateListener = listener;
-    }
-
-    public void setReady() {
-        MosaicRenderer.ready();
-    }
-
-    public void preprocess(float[] transformMatrix) {
-        MosaicRenderer.preprocess(transformMatrix);
-    }
-
-    public void transferGPUtoCPU() {
-        MosaicRenderer.transferGPUtoCPU();
-    }
-
-    public void setWarping(boolean flag) {
-        MosaicRenderer.setWarping(flag);
-    }
-}
diff --git a/src/com/android/camera/panorama/PanoProgressBar.java b/src/com/android/camera/panorama/PanoProgressBar.java
deleted file mode 100644
index e575b75..0000000
--- a/src/com/android/camera/panorama/PanoProgressBar.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.RectF;
-import android.util.AttributeSet;
-import android.widget.ImageView;
-
-class PanoProgressBar extends ImageView {
-    private static final String TAG = "PanoProgressBar";
-    public static final int DIRECTION_NONE = 0;
-    public static final int DIRECTION_LEFT = 1;
-    public static final int DIRECTION_RIGHT = 2;
-    private float mProgress = 0;
-    private float mMaxProgress = 0;
-    private float mLeftMostProgress = 0;
-    private float mRightMostProgress = 0;
-    private float mProgressOffset = 0;
-    private float mIndicatorWidth = 0;
-    private int mDirection = 0;
-    private final Paint mBackgroundPaint = new Paint();
-    private final Paint mDoneAreaPaint = new Paint();
-    private final Paint mIndicatorPaint = new Paint();
-    private float mWidth;
-    private float mHeight;
-    private RectF mDrawBounds;
-    private OnDirectionChangeListener mListener = null;
-
-    public interface OnDirectionChangeListener {
-        public void onDirectionChange(int direction);
-    }
-
-    public PanoProgressBar(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        mDoneAreaPaint.setStyle(Paint.Style.FILL);
-        mDoneAreaPaint.setAlpha(0xff);
-
-        mBackgroundPaint.setStyle(Paint.Style.FILL);
-        mBackgroundPaint.setAlpha(0xff);
-
-        mIndicatorPaint.setStyle(Paint.Style.FILL);
-        mIndicatorPaint.setAlpha(0xff);
-
-        mDrawBounds = new RectF();
-    }
-
-    public void setOnDirectionChangeListener(OnDirectionChangeListener l) {
-        mListener = l;
-    }
-
-    private void setDirection(int direction) {
-        if (mDirection != direction) {
-            mDirection = direction;
-            if (mListener != null) {
-                mListener.onDirectionChange(mDirection);
-            }
-            invalidate();
-        }
-    }
-
-    public int getDirection() {
-        return mDirection;
-    }
-
-    public void setBackgroundColor(int color) {
-        mBackgroundPaint.setColor(color);
-        invalidate();
-    }
-
-    public void setDoneColor(int color) {
-        mDoneAreaPaint.setColor(color);
-        invalidate();
-    }
-
-    public void setIndicatorColor(int color) {
-        mIndicatorPaint.setColor(color);
-        invalidate();
-    }
-
-    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-        mWidth = w;
-        mHeight = h;
-        mDrawBounds.set(0, 0, mWidth, mHeight);
-    }
-
-    public void setMaxProgress(int progress) {
-        mMaxProgress = progress;
-    }
-
-    public void setIndicatorWidth(float w) {
-        mIndicatorWidth = w;
-        invalidate();
-    }
-
-    public void setRightIncreasing(boolean rightIncreasing) {
-        if (rightIncreasing) {
-            mLeftMostProgress = 0;
-            mRightMostProgress = 0;
-            mProgressOffset = 0;
-            setDirection(DIRECTION_RIGHT);
-        } else {
-            mLeftMostProgress = mWidth;
-            mRightMostProgress = mWidth;
-            mProgressOffset = mWidth;
-            setDirection(DIRECTION_LEFT);
-        }
-        invalidate();
-    }
-
-    public void setProgress(int progress) {
-        // The panning direction will be decided after user pan more than 10 degrees in one
-        // direction.
-        if (mDirection == DIRECTION_NONE) {
-            if (progress > 10) {
-                setRightIncreasing(true);
-            } else if (progress < -10) {
-                setRightIncreasing(false);
-            }
-        }
-        // mDirection might be modified by setRightIncreasing() above. Need to check again.
-        if (mDirection != DIRECTION_NONE) {
-            mProgress = progress * mWidth / mMaxProgress + mProgressOffset;
-            // value bounds.
-            mProgress = Math.min(mWidth, Math.max(0, mProgress));
-            if (mDirection == DIRECTION_RIGHT) {
-                // The right most progress is adjusted.
-                mRightMostProgress = Math.max(mRightMostProgress, mProgress);
-            }
-            if (mDirection == DIRECTION_LEFT) {
-                // The left most progress is adjusted.
-                mLeftMostProgress = Math.min(mLeftMostProgress, mProgress);
-            }
-            invalidate();
-        }
-    }
-
-    public void reset() {
-        mProgress = 0;
-        mProgressOffset = 0;
-        setDirection(DIRECTION_NONE);
-        invalidate();
-    }
-
-    @Override
-    protected void onDraw(Canvas canvas) {
-        // the background
-        canvas.drawRect(mDrawBounds, mBackgroundPaint);
-        if (mDirection != DIRECTION_NONE) {
-            // the progress area
-            canvas.drawRect(mLeftMostProgress, mDrawBounds.top, mRightMostProgress,
-                    mDrawBounds.bottom, mDoneAreaPaint);
-            // the indication bar
-            float l;
-            float r;
-            if (mDirection == DIRECTION_RIGHT) {
-                l = Math.max(mProgress - mIndicatorWidth, 0f);
-                r = mProgress;
-            } else {
-                l = mProgress;
-                r = Math.min(mProgress + mIndicatorWidth, mWidth);
-            }
-            canvas.drawRect(l, mDrawBounds.top, r, mDrawBounds.bottom, mIndicatorPaint);
-        }
-
-        // draw the mask image on the top for shaping.
-        super.onDraw(canvas);
-    }
-}
diff --git a/src/com/android/camera/panorama/PanoUtil.java b/src/com/android/camera/panorama/PanoUtil.java
deleted file mode 100644
index ef778a3..0000000
--- a/src/com/android/camera/panorama/PanoUtil.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-public class PanoUtil {
-    public static String createName(String format, long dateTaken) {
-        Date date = new Date(dateTaken);
-        SimpleDateFormat dateFormat = new SimpleDateFormat(format);
-        return dateFormat.format(date);
-    }
-
-    // TODO: Add comments about the range of these two arguments.
-    public static double calculateDifferenceBetweenAngles(double firstAngle,
-            double secondAngle) {
-        double difference1 = (secondAngle - firstAngle) % 360;
-        if (difference1 < 0) {
-            difference1 += 360;
-        }
-
-        double difference2 = (firstAngle - secondAngle) % 360;
-        if (difference2 < 0) {
-            difference2 += 360;
-        }
-
-        return Math.min(difference1, difference2);
-    }
-
-    public static void decodeYUV420SPQuarterRes(int[] rgb, byte[] yuv420sp, int width, int height) {
-        final int frameSize = width * height;
-
-        for (int j = 0, ypd = 0; j < height; j += 4) {
-            int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;
-            for (int i = 0; i < width; i += 4, ypd++) {
-                int y = (0xff & ((int) yuv420sp[j * width + i])) - 16;
-                if (y < 0) {
-                    y = 0;
-                }
-                if ((i & 1) == 0) {
-                    v = (0xff & yuv420sp[uvp++]) - 128;
-                    u = (0xff & yuv420sp[uvp++]) - 128;
-                    uvp += 2;  // Skip the UV values for the 4 pixels skipped in between
-                }
-                int y1192 = 1192 * y;
-                int r = (y1192 + 1634 * v);
-                int g = (y1192 - 833 * v - 400 * u);
-                int b = (y1192 + 2066 * u);
-
-                if (r < 0) {
-                    r = 0;
-                } else if (r > 262143) {
-                    r = 262143;
-                }
-                if (g < 0) {
-                    g = 0;
-                } else if (g > 262143) {
-                    g = 262143;
-                }
-                if (b < 0) {
-                    b = 0;
-                } else if (b > 262143) {
-                    b = 262143;
-                }
-
-                rgb[ypd] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) |
-                        ((b >> 10) & 0xff);
-            }
-        }
-    }
-}
diff --git a/src/com/android/camera/panorama/PanoramaActivity.java b/src/com/android/camera/panorama/PanoramaActivity.java
deleted file mode 100755
index 01d5ff9..0000000
--- a/src/com/android/camera/panorama/PanoramaActivity.java
+++ /dev/null
@@ -1,1170 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-import com.android.camera.ActivityBase;
-import com.android.camera.CameraDisabledException;
-import com.android.camera.CameraHardwareException;
-import com.android.camera.CameraHolder;
-import com.android.camera.Exif;
-import com.android.camera.MenuHelper;
-import com.android.camera.ModePicker;
-import com.android.camera.OnClickAttr;
-import com.android.camera.R;
-import com.android.camera.RotateDialogController;
-import com.android.camera.ShutterButton;
-import com.android.camera.Storage;
-import com.android.camera.Thumbnail;
-import com.android.camera.Util;
-import com.android.camera.ui.PopupManager;
-import com.android.camera.ui.Rotatable;
-import com.android.camera.ui.RotateImageView;
-import com.android.camera.ui.RotateLayout;
-import com.android.camera.ui.SharePopup;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.content.pm.ActivityInfo;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.ImageFormat;
-import android.graphics.PixelFormat;
-import android.graphics.Rect;
-import android.graphics.SurfaceTexture;
-import android.graphics.YuvImage;
-import android.hardware.Camera.Parameters;
-import android.hardware.Camera.Size;
-import android.hardware.Sensor;
-import android.hardware.SensorManager;
-import android.media.ExifInterface;
-import android.media.MediaActionSound;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.os.ParcelFileDescriptor;
-import android.os.PowerManager;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.OrientationEventListener;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-
-/**
- * Activity to handle panorama capturing.
- */
-public class PanoramaActivity extends ActivityBase implements
-        ModePicker.OnModeChangeListener, SurfaceTexture.OnFrameAvailableListener,
-        ShutterButton.OnShutterButtonListener,
-        MosaicRendererSurfaceViewRenderer.MosaicSurfaceCreateListener {
-    public static final int DEFAULT_SWEEP_ANGLE = 160;
-    public static final int DEFAULT_BLEND_MODE = Mosaic.BLENDTYPE_HORIZONTAL;
-    public static final int DEFAULT_CAPTURE_PIXELS = 960 * 720;
-
-    private static final int MSG_LOW_RES_FINAL_MOSAIC_READY = 1;
-    private static final int MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL = 2;
-    private static final int MSG_GENERATE_FINAL_MOSAIC_ERROR = 3;
-    private static final int MSG_RESET_TO_PREVIEW = 4;
-    private static final int MSG_CLEAR_SCREEN_DELAY = 5;
-
-    private static final int SCREEN_DELAY = 2 * 60 * 1000;
-
-    private static final String TAG = "PanoramaActivity";
-    private static final int PREVIEW_STOPPED = 0;
-    private static final int PREVIEW_ACTIVE = 1;
-    private static final int CAPTURE_STATE_VIEWFINDER = 0;
-    private static final int CAPTURE_STATE_MOSAIC = 1;
-
-    // Speed is in unit of deg/sec
-    private static final float PANNING_SPEED_THRESHOLD = 20f;
-
-    // Ratio of nanosecond to second
-    private static final float NS2S = 1.0f / 1000000000.0f;
-
-    private boolean mPausing;
-
-    private View mPanoLayout;
-    private View mCaptureLayout;
-    private View mReviewLayout;
-    private ImageView mReview;
-    private RotateLayout mCaptureIndicator;
-    private PanoProgressBar mPanoProgressBar;
-    private PanoProgressBar mSavingProgressBar;
-    private View mFastIndicationBorder;
-    private View mLeftIndicator;
-    private View mRightIndicator;
-    private MosaicRendererSurfaceView mMosaicView;
-    private TextView mTooFastPrompt;
-    private ShutterButton mShutterButton;
-    private Object mWaitObject = new Object();
-
-    private String mPreparePreviewString;
-    private String mDialogTitle;
-    private String mDialogOkString;
-    private String mDialogPanoramaFailedString;
-
-    private int mIndicatorColor;
-    private int mIndicatorColorFast;
-
-    private float mCompassValueX;
-    private float mCompassValueY;
-    private float mCompassValueXStart;
-    private float mCompassValueYStart;
-    private float mCompassValueXStartBuffer;
-    private float mCompassValueYStartBuffer;
-    private int mCompassThreshold;
-    private int mTraversedAngleX;
-    private int mTraversedAngleY;
-    private long mTimestamp;
-
-    private RotateImageView mThumbnailView;
-    private Thumbnail mThumbnail;
-    private SharePopup mSharePopup;
-
-    private int mPreviewWidth;
-    private int mPreviewHeight;
-    private int mCameraState;
-    private int mCaptureState;
-    private SensorManager mSensorManager;
-    private Sensor mSensor;
-    private PowerManager.WakeLock mPartialWakeLock;
-    private ModePicker mModePicker;
-    private MosaicFrameProcessor mMosaicFrameProcessor;
-    private long mTimeTaken;
-    private Handler mMainHandler;
-    private SurfaceTexture mSurfaceTexture;
-    private boolean mThreadRunning;
-    private boolean mCancelComputation;
-    private float[] mTransformMatrix;
-    private float mHorizontalViewAngle;
-    private float mVerticalViewAngle;
-
-    // Prefer FOCUS_MODE_INFINITY to FOCUS_MODE_CONTINUOUS_VIDEO because of
-    // getting a better image quality by the former.
-    private String mTargetFocusMode = Parameters.FOCUS_MODE_INFINITY;
-
-    private PanoOrientationEventListener mOrientationEventListener;
-    // The value could be 0, 90, 180, 270 for the 4 different orientations measured in clockwise
-    // respectively.
-    private int mDeviceOrientation;
-    private int mDeviceOrientationAtCapture;
-    private int mCameraOrientation;
-    private int mOrientationCompensation;
-
-    private RotateDialogController mRotateDialog;
-
-    private MediaActionSound mCameraSound;
-
-    private class MosaicJpeg {
-        public MosaicJpeg(byte[] data, int width, int height) {
-            this.data = data;
-            this.width = width;
-            this.height = height;
-            this.isValid = true;
-        }
-
-        public MosaicJpeg() {
-            this.data = null;
-            this.width = 0;
-            this.height = 0;
-            this.isValid = false;
-        }
-
-        public final byte[] data;
-        public final int width;
-        public final int height;
-        public final boolean isValid;
-    }
-
-    private class PanoOrientationEventListener extends OrientationEventListener {
-        public PanoOrientationEventListener(Context context) {
-            super(context);
-        }
-
-        @Override
-        public void onOrientationChanged(int orientation) {
-            // We keep the last known orientation. So if the user first orient
-            // the camera then point the camera to floor or sky, we still have
-            // the correct orientation.
-            if (orientation == ORIENTATION_UNKNOWN) return;
-            mDeviceOrientation = Util.roundOrientation(orientation, mDeviceOrientation);
-            // When the screen is unlocked, display rotation may change. Always
-            // calculate the up-to-date orientationCompensation.
-            int orientationCompensation = mDeviceOrientation
-                    + Util.getDisplayRotation(PanoramaActivity.this);
-            if (mOrientationCompensation != orientationCompensation) {
-                mOrientationCompensation = orientationCompensation;
-                setOrientationIndicator(mOrientationCompensation);
-            }
-        }
-    }
-
-    private void setOrientationIndicator(int degree) {
-        if (mSharePopup != null) mSharePopup.setOrientation(degree);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        super.onCreateOptionsMenu(menu);
-
-        addBaseMenuItems(menu);
-        return true;
-    }
-
-    @Override
-    public boolean onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        // Only show the menu when idle.
-        boolean idle = (mCaptureState == CAPTURE_STATE_VIEWFINDER && !mThreadRunning);
-        for (int i = 0; i < menu.size(); i++) {
-            MenuItem item = menu.getItem(i);
-            item.setVisible(idle);
-            item.setEnabled(idle);
-        }
-
-        return true;
-    }
-
-    private void addBaseMenuItems(Menu menu) {
-        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_CAMERA, new Runnable() {
-            public void run() {
-                switchToOtherMode(ModePicker.MODE_CAMERA);
-            }
-        });
-        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_VIDEO, new Runnable() {
-            public void run() {
-                switchToOtherMode(ModePicker.MODE_VIDEO);
-            }
-        });
-    }
-
-    @Override
-    public void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-
-        Window window = getWindow();
-        Util.enterLightsOutMode(window);
-        Util.initializeScreenBrightness(window, getContentResolver());
-
-        createContentView();
-
-        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
-        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
-        if (mSensor == null) {
-            mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
-        }
-        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        mPartialWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Panorama");
-
-        mOrientationEventListener = new PanoOrientationEventListener(this);
-
-        mTransformMatrix = new float[16];
-
-        mPreparePreviewString =
-                getResources().getString(R.string.pano_dialog_prepare_preview);
-        mDialogTitle = getResources().getString(R.string.pano_dialog_title);
-        mDialogOkString = getResources().getString(R.string.dialog_ok);
-        mDialogPanoramaFailedString =
-                getResources().getString(R.string.pano_dialog_panorama_failed);
-        mCameraSound = new MediaActionSound();
-
-        mMainHandler = new Handler() {
-            @Override
-            public void handleMessage(Message msg) {
-                switch (msg.what) {
-                    case MSG_LOW_RES_FINAL_MOSAIC_READY:
-                        onBackgroundThreadFinished();
-                        showFinalMosaic((Bitmap) msg.obj);
-                        saveHighResMosaic();
-                        break;
-                    case MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL:
-                        onBackgroundThreadFinished();
-                        // If the activity is paused, save the thumbnail to the file here.
-                        // If not, it will be saved in onPause.
-                        if (mPausing) saveThumbnailToFile();
-                        // Set the thumbnail bitmap here because mThumbnailView must be accessed
-                        // from the UI thread.
-                        updateThumbnailButton();
-
-                        // Share popup may still have the reference to the old thumbnail. Clear it.
-                        mSharePopup = null;
-                        resetToPreview();
-                        break;
-                    case MSG_GENERATE_FINAL_MOSAIC_ERROR:
-                        onBackgroundThreadFinished();
-                        if (mPausing) {
-                            resetToPreview();
-                        } else {
-                            mRotateDialog.showAlertDialog(
-                                    mDialogTitle, mDialogPanoramaFailedString,
-                                    mDialogOkString, new Runnable() {
-                                        @Override
-                                        public void run() {
-                                            resetToPreview();
-                                        }},
-                                    null, null);
-                        }
-                        break;
-                    case MSG_RESET_TO_PREVIEW:
-                        onBackgroundThreadFinished();
-                        resetToPreview();
-                        break;
-                    case MSG_CLEAR_SCREEN_DELAY:
-                        getWindow().clearFlags(WindowManager.LayoutParams.
-                                FLAG_KEEP_SCREEN_ON);
-                        break;
-                }
-                clearMosaicFrameProcessorIfNeeded();
-            }
-        };
-    }
-
-    private void setupCamera() throws CameraHardwareException, CameraDisabledException {
-        openCamera();
-        Parameters parameters = mCameraDevice.getParameters();
-        setupCaptureParams(parameters);
-        configureCamera(parameters);
-    }
-
-    private void releaseCamera() {
-        if (mCameraDevice != null) {
-            mCameraDevice.setPreviewCallbackWithBuffer(null);
-            CameraHolder.instance().release();
-            mCameraDevice = null;
-            mCameraState = PREVIEW_STOPPED;
-        }
-    }
-
-    private void openCamera() throws CameraHardwareException, CameraDisabledException {
-        int backCameraId = CameraHolder.instance().getBackCameraId();
-        mCameraDevice = Util.openCamera(this, backCameraId);
-        mCameraOrientation = Util.getCameraOrientation(backCameraId);
-    }
-
-    private boolean findBestPreviewSize(List<Size> supportedSizes, boolean need4To3,
-            boolean needSmaller) {
-        int pixelsDiff = DEFAULT_CAPTURE_PIXELS;
-        boolean hasFound = false;
-        for (Size size : supportedSizes) {
-            int h = size.height;
-            int w = size.width;
-            // we only want 4:3 format.
-            int d = DEFAULT_CAPTURE_PIXELS - h * w;
-            if (needSmaller && d < 0) { // no bigger preview than 960x720.
-                continue;
-            }
-            if (need4To3 && (h * 4 != w * 3)) {
-                continue;
-            }
-            d = Math.abs(d);
-            if (d < pixelsDiff) {
-                mPreviewWidth = w;
-                mPreviewHeight = h;
-                pixelsDiff = d;
-                hasFound = true;
-            }
-        }
-        return hasFound;
-    }
-
-    private void setupCaptureParams(Parameters parameters) {
-        List<Size> supportedSizes = parameters.getSupportedPreviewSizes();
-        if (!findBestPreviewSize(supportedSizes, true, true)) {
-            Log.w(TAG, "No 4:3 ratio preview size supported.");
-            if (!findBestPreviewSize(supportedSizes, false, true)) {
-                Log.w(TAG, "Can't find a supported preview size smaller than 960x720.");
-                findBestPreviewSize(supportedSizes, false, false);
-            }
-        }
-        Log.v(TAG, "preview h = " + mPreviewHeight + " , w = " + mPreviewWidth);
-        parameters.setPreviewSize(mPreviewWidth, mPreviewHeight);
-
-        List<int[]> frameRates = parameters.getSupportedPreviewFpsRange();
-        int last = frameRates.size() - 1;
-        int minFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MIN_INDEX];
-        int maxFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MAX_INDEX];
-        parameters.setPreviewFpsRange(minFps, maxFps);
-        Log.v(TAG, "preview fps: " + minFps + ", " + maxFps);
-
-        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
-        if (supportedFocusModes.indexOf(mTargetFocusMode) >= 0) {
-            parameters.setFocusMode(mTargetFocusMode);
-        } else {
-            // Use the default focus mode and log a message
-            Log.w(TAG, "Cannot set the focus mode to " + mTargetFocusMode +
-                  " becuase the mode is not supported.");
-        }
-
-        parameters.setRecordingHint(false);
-
-        mHorizontalViewAngle = parameters.getHorizontalViewAngle();
-        mVerticalViewAngle =  parameters.getVerticalViewAngle();
-    }
-
-    public int getPreviewBufSize() {
-        PixelFormat pixelInfo = new PixelFormat();
-        PixelFormat.getPixelFormatInfo(mCameraDevice.getParameters().getPreviewFormat(), pixelInfo);
-        // TODO: remove this extra 32 byte after the driver bug is fixed.
-        return (mPreviewWidth * mPreviewHeight * pixelInfo.bitsPerPixel / 8) + 32;
-    }
-
-    private void configureCamera(Parameters parameters) {
-        mCameraDevice.setParameters(parameters);
-    }
-
-    private boolean switchToOtherMode(int mode) {
-        if (isFinishing()) {
-            return false;
-        }
-        MenuHelper.gotoMode(mode, this);
-        finish();
-        return true;
-    }
-
-    public boolean onModeChanged(int mode) {
-        if (mode != ModePicker.MODE_PANORAMA) {
-            return switchToOtherMode(mode);
-        } else {
-            return true;
-        }
-    }
-
-    @Override
-    public void onMosaicSurfaceChanged() {
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                // If panorama is generating low res or high res mosaic, it
-                // means users exit and come back to panorama. Do not start the
-                // preview. Preview will be started after final mosaic is
-                // generated.
-                if (!mPausing) {
-                    startCameraPreview();
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onMosaicSurfaceCreated(final int textureID) {
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                if (mSurfaceTexture != null) {
-                    mSurfaceTexture.release();
-                }
-                mSurfaceTexture = new SurfaceTexture(textureID);
-                if (!mPausing) {
-                    mSurfaceTexture.setOnFrameAvailableListener(PanoramaActivity.this);
-                }
-            }
-        });
-    }
-
-    public void runViewFinder() {
-        mMosaicView.setWarping(false);
-        // Call preprocess to render it to low-res and high-res RGB textures.
-        mMosaicView.preprocess(mTransformMatrix);
-        mMosaicView.setReady();
-        mMosaicView.requestRender();
-    }
-
-    public void runMosaicCapture() {
-        mMosaicView.setWarping(true);
-        // Call preprocess to render it to low-res and high-res RGB textures.
-        mMosaicView.preprocess(mTransformMatrix);
-        // Lock the conditional variable to ensure the order of transferGPUtoCPU and
-        // mMosaicFrame.processFrame().
-        mMosaicView.lockPreviewReadyFlag();
-        // Now, transfer the textures from GPU to CPU memory for processing
-        mMosaicView.transferGPUtoCPU();
-        // Wait on the condition variable (will be opened when GPU->CPU transfer is done).
-        mMosaicView.waitUntilPreviewReady();
-        mMosaicFrameProcessor.processFrame();
-    }
-
-    public synchronized void onFrameAvailable(SurfaceTexture surface) {
-        /* This function may be called by some random thread,
-         * so let's be safe and use synchronize. No OpenGL calls can be done here.
-         */
-        // Frames might still be available after the activity is paused. If we call onFrameAvailable
-        // after pausing, the GL thread will crash.
-        if (mPausing) return;
-
-        // Updating the texture should be done in the GL thread which mMosaicView is attached.
-        mMosaicView.queueEvent(new Runnable() {
-            @Override
-            public void run() {
-                // Check if the activity is paused here can speed up the onPause() process.
-                if (mPausing) return;
-                mSurfaceTexture.updateTexImage();
-                mSurfaceTexture.getTransformMatrix(mTransformMatrix);
-            }
-        });
-        // Update the transformation matrix for mosaic pre-process.
-        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
-            runViewFinder();
-        } else {
-            runMosaicCapture();
-        }
-    }
-
-    private void hideDirectionIndicators() {
-        mLeftIndicator.setVisibility(View.GONE);
-        mRightIndicator.setVisibility(View.GONE);
-    }
-
-    private void showDirectionIndicators(int direction) {
-        switch (direction) {
-            case PanoProgressBar.DIRECTION_NONE:
-                mLeftIndicator.setVisibility(View.VISIBLE);
-                mRightIndicator.setVisibility(View.VISIBLE);
-                break;
-            case PanoProgressBar.DIRECTION_LEFT:
-                mLeftIndicator.setVisibility(View.VISIBLE);
-                mRightIndicator.setVisibility(View.GONE);
-                break;
-            case PanoProgressBar.DIRECTION_RIGHT:
-                mLeftIndicator.setVisibility(View.GONE);
-                mRightIndicator.setVisibility(View.VISIBLE);
-                break;
-        }
-    }
-
-    public void startCapture() {
-        // Reset values so we can do this again.
-        mCancelComputation = false;
-        mTimeTaken = System.currentTimeMillis();
-        mCaptureState = CAPTURE_STATE_MOSAIC;
-        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan_recording);
-        mCaptureIndicator.setVisibility(View.VISIBLE);
-        showDirectionIndicators(PanoProgressBar.DIRECTION_NONE);
-        mThumbnailView.setEnabled(false);
-
-        mCompassValueXStart = mCompassValueXStartBuffer;
-        mCompassValueYStart = mCompassValueYStartBuffer;
-        mTimestamp = 0;
-
-        mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener() {
-            @Override
-            public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
-                    float progressX, float progressY) {
-                float accumulatedHorizontalAngle = progressX * mHorizontalViewAngle;
-                float accumulatedVerticalAngle = progressY * mVerticalViewAngle;
-                if (isFinished
-                        || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE)
-                        || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)) {
-                    stopCapture(false);
-                } else {
-                    float panningRateXInDegree = panningRateX * mHorizontalViewAngle;
-                    float panningRateYInDegree = panningRateY * mVerticalViewAngle;
-                    updateProgress(panningRateXInDegree, panningRateYInDegree,
-                            accumulatedHorizontalAngle, accumulatedVerticalAngle);
-                }
-            }
-        });
-
-        if (mModePicker != null) mModePicker.setEnabled(false);
-
-        mPanoProgressBar.reset();
-        // TODO: calculate the indicator width according to different devices to reflect the actual
-        // angle of view of the camera device.
-        mPanoProgressBar.setIndicatorWidth(20);
-        mPanoProgressBar.setMaxProgress(DEFAULT_SWEEP_ANGLE);
-        mPanoProgressBar.setVisibility(View.VISIBLE);
-        mDeviceOrientationAtCapture = mDeviceOrientation;
-        keepScreenOn();
-    }
-
-    private void stopCapture(boolean aborted) {
-        mCaptureState = CAPTURE_STATE_VIEWFINDER;
-        mCaptureIndicator.setVisibility(View.GONE);
-        hideTooFastIndication();
-        hideDirectionIndicators();
-        mThumbnailView.setEnabled(true);
-
-        mMosaicFrameProcessor.setProgressListener(null);
-        stopCameraPreview();
-
-        mSurfaceTexture.setOnFrameAvailableListener(null);
-
-        if (!aborted && !mThreadRunning) {
-            mRotateDialog.showWaitingDialog(mPreparePreviewString);
-            runBackgroundThread(new Thread() {
-                @Override
-                public void run() {
-                    MosaicJpeg jpeg = generateFinalMosaic(false);
-
-                    if (jpeg != null && jpeg.isValid) {
-                        Bitmap bitmap = null;
-                        bitmap = BitmapFactory.decodeByteArray(jpeg.data, 0, jpeg.data.length);
-                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
-                                MSG_LOW_RES_FINAL_MOSAIC_READY, bitmap));
-                    } else {
-                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
-                                MSG_RESET_TO_PREVIEW));
-                    }
-                }
-            });
-        }
-        // do we have to wait for the thread to complete before enabling this?
-        if (mModePicker != null) mModePicker.setEnabled(true);
-        keepScreenOnAwhile();
-    }
-
-    private void showTooFastIndication() {
-        mTooFastPrompt.setVisibility(View.VISIBLE);
-        mFastIndicationBorder.setVisibility(View.VISIBLE);
-        mPanoProgressBar.setIndicatorColor(mIndicatorColorFast);
-        mLeftIndicator.setEnabled(true);
-        mRightIndicator.setEnabled(true);
-    }
-
-    private void hideTooFastIndication() {
-        mTooFastPrompt.setVisibility(View.GONE);
-        mFastIndicationBorder.setVisibility(View.GONE);
-        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
-        mLeftIndicator.setEnabled(false);
-        mRightIndicator.setEnabled(false);
-    }
-
-    private void updateProgress(float panningRateXInDegree, float panningRateYInDegree,
-            float progressHorizontalAngle, float progressVerticalAngle) {
-        mMosaicView.setReady();
-        mMosaicView.requestRender();
-
-        // TODO: Now we just display warning message by the panning speed.
-        // Since we only support horizontal panning, we should display a warning message
-        // in UI when there're significant vertical movements.
-        if ((Math.abs(panningRateXInDegree) > PANNING_SPEED_THRESHOLD)
-            || (Math.abs(panningRateYInDegree) > PANNING_SPEED_THRESHOLD)) {
-            showTooFastIndication();
-        } else {
-            hideTooFastIndication();
-        }
-        int angleInMajorDirection =
-                (Math.abs(progressHorizontalAngle) > Math.abs(progressVerticalAngle))
-                ? (int) progressHorizontalAngle
-                : (int) progressVerticalAngle;
-        mPanoProgressBar.setProgress((angleInMajorDirection));
-    }
-
-    private void createContentView() {
-        setContentView(R.layout.panorama);
-
-        mCaptureState = CAPTURE_STATE_VIEWFINDER;
-
-        Resources appRes = getResources();
-
-        mCaptureLayout = (View) findViewById(R.id.pano_capture_layout);
-        mPanoProgressBar = (PanoProgressBar) findViewById(R.id.pano_pan_progress_bar);
-        mPanoProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
-        mPanoProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_done));
-        mIndicatorColor = appRes.getColor(R.color.pano_progress_indication);
-        mIndicatorColorFast = appRes.getColor(R.color.pano_progress_indication_fast);
-        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
-        mPanoProgressBar.setOnDirectionChangeListener(
-                new PanoProgressBar.OnDirectionChangeListener () {
-                    @Override
-                    public void onDirectionChange(int direction) {
-                        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
-                            showDirectionIndicators(direction);
-                        }
-                    }
-                });
-
-        mLeftIndicator = (ImageView) findViewById(R.id.pano_pan_left_indicator);
-        mRightIndicator = (ImageView) findViewById(R.id.pano_pan_right_indicator);
-        mLeftIndicator.setEnabled(false);
-        mRightIndicator.setEnabled(false);
-        mTooFastPrompt = (TextView) findViewById(R.id.pano_capture_too_fast_textview);
-        mFastIndicationBorder = (View) findViewById(R.id.pano_speed_indication_border);
-
-        mSavingProgressBar = (PanoProgressBar) findViewById(R.id.pano_saving_progress_bar);
-        mSavingProgressBar.setIndicatorWidth(0);
-        mSavingProgressBar.setMaxProgress(100);
-        mSavingProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
-        mSavingProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_indication));
-
-        mCaptureIndicator = (RotateLayout) findViewById(R.id.pano_capture_indicator);
-
-        mThumbnailView = (RotateImageView) findViewById(R.id.thumbnail);
-        mThumbnailView.enableFilter(false);
-
-        mReviewLayout = (View) findViewById(R.id.pano_review_layout);
-        mReview = (ImageView) findViewById(R.id.pano_reviewarea);
-        mMosaicView = (MosaicRendererSurfaceView) findViewById(R.id.pano_renderer);
-        mMosaicView.getRenderer().setMosaicSurfaceCreateListener(this);
-
-        mModePicker = (ModePicker) findViewById(R.id.mode_picker);
-        mModePicker.setVisibility(View.VISIBLE);
-        mModePicker.setOnModeChangeListener(this);
-        mModePicker.setCurrentMode(ModePicker.MODE_PANORAMA);
-
-        mShutterButton = (ShutterButton) findViewById(R.id.shutter_button);
-        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
-        mShutterButton.setOnShutterButtonListener(this);
-
-        mPanoLayout = findViewById(R.id.pano_layout);
-
-        mRotateDialog = new RotateDialogController(this, R.layout.rotate_dialog);
-
-        if (getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) {
-            Rotatable[] rotateLayout = {
-                    (Rotatable) findViewById(R.id.pano_pan_progress_bar_layout),
-                    (Rotatable) findViewById(R.id.pano_capture_too_fast_textview_layout),
-                    (Rotatable) findViewById(R.id.pano_review_saving_indication_layout),
-                    (Rotatable) findViewById(R.id.pano_saving_progress_bar_layout),
-                    (Rotatable) findViewById(R.id.pano_review_cancel_button_layout),
-                    (Rotatable) findViewById(R.id.pano_rotate_reviewarea),
-                    (Rotatable) mRotateDialog,
-                    (Rotatable) mCaptureIndicator,
-                    (Rotatable) mModePicker,
-                    (Rotatable) mThumbnailView};
-            for (Rotatable r : rotateLayout) {
-                r.setOrientation(270);
-            }
-        }
-    }
-
-    @Override
-    public void onShutterButtonClick() {
-        // If mSurfaceTexture == null then GL setup is not finished yet.
-        // No buttons can be pressed.
-        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
-        // Since this button will stay on the screen when capturing, we need to check the state
-        // right now.
-        switch (mCaptureState) {
-            case CAPTURE_STATE_VIEWFINDER:
-                mCameraSound.play(MediaActionSound.START_VIDEO_RECORDING);
-                startCapture();
-                break;
-            case CAPTURE_STATE_MOSAIC:
-                mCameraSound.play(MediaActionSound.STOP_VIDEO_RECORDING);
-                stopCapture(false);
-        }
-    }
-
-    @Override
-    public void onShutterButtonFocus(boolean pressed) {
-    }
-
-    public void reportProgress() {
-        mSavingProgressBar.reset();
-        mSavingProgressBar.setRightIncreasing(true);
-        Thread t = new Thread() {
-            @Override
-            public void run() {
-                while (mThreadRunning) {
-                    final int progress = mMosaicFrameProcessor.reportProgress(
-                            true, mCancelComputation);
-
-                    try {
-                        synchronized (mWaitObject) {
-                            mWaitObject.wait(50);
-                        }
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException("Panorama reportProgress failed", e);
-                    }
-                    // Update the progress bar
-                    runOnUiThread(new Runnable() {
-                        public void run() {
-                            mSavingProgressBar.setProgress(progress);
-                        }
-                    });
-                }
-            }
-        };
-        t.start();
-    }
-
-    private void initThumbnailButton() {
-        // Load the thumbnail from the disk.
-        if (mThumbnail == null) {
-            mThumbnail = Thumbnail.loadFrom(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
-        }
-        updateThumbnailButton();
-    }
-
-    private void updateThumbnailButton() {
-        // Update last image if URI is invalid and the storage is ready.
-        ContentResolver contentResolver = getContentResolver();
-        if ((mThumbnail == null || !Util.isUriValid(mThumbnail.getUri(), contentResolver))) {
-            mThumbnail = Thumbnail.getLastThumbnail(contentResolver);
-        }
-        if (mThumbnail != null) {
-            mThumbnailView.setBitmap(mThumbnail.getBitmap());
-        } else {
-            mThumbnailView.setBitmap(null);
-        }
-    }
-
-    private void saveThumbnailToFile() {
-        if (mThumbnail != null && !mThumbnail.fromFile()) {
-            mThumbnail.saveTo(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
-        }
-    }
-
-    public void saveHighResMosaic() {
-        runBackgroundThread(new Thread() {
-            @Override
-            public void run() {
-                mPartialWakeLock.acquire();
-                MosaicJpeg jpeg;
-                try {
-                    jpeg = generateFinalMosaic(true);
-                } finally {
-                    mPartialWakeLock.release();
-                }
-
-                if (jpeg == null) {  // Cancelled by user.
-                    mMainHandler.sendEmptyMessage(MSG_RESET_TO_PREVIEW);
-                } else if (!jpeg.isValid) {  // Error when generating mosaic.
-                    mMainHandler.sendEmptyMessage(MSG_GENERATE_FINAL_MOSAIC_ERROR);
-                } else {
-                    // The panorama image returned from the library is orientated based on the
-                    // natural orientation of a camera. We need to set an orientation for the image
-                    // in its EXIF header, so the image can be displayed correctly.
-                    // The orientation is calculated from compensating the
-                    // device orientation at capture and the camera orientation respective to
-                    // the natural orientation of the device.
-                    int orientation = (mDeviceOrientationAtCapture + mCameraOrientation) % 360;
-                    Uri uri = savePanorama(jpeg.data, jpeg.width, jpeg.height, orientation);
-                    if (uri != null) {
-                        // Create a thumbnail whose width or height is equal or bigger
-                        // than the screen's width or height.
-                        int widthRatio = (int) Math.ceil((double) jpeg.width
-                                / mPanoLayout.getWidth());
-                        int heightRatio = (int) Math.ceil((double) jpeg.height
-                                / mPanoLayout.getHeight());
-                        int inSampleSize = Integer.highestOneBit(
-                                Math.max(widthRatio, heightRatio));
-                        mThumbnail = Thumbnail.createThumbnail(
-                                jpeg.data, orientation, inSampleSize, uri);
-                        Util.broadcastNewPicture(PanoramaActivity.this, uri);
-                    }
-                    mMainHandler.sendMessage(
-                            mMainHandler.obtainMessage(MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL));
-                }
-            }
-        });
-        reportProgress();
-    }
-
-    private void runBackgroundThread(Thread thread) {
-        mThreadRunning = true;
-        thread.start();
-    }
-
-    private void onBackgroundThreadFinished() {
-        mThreadRunning = false;
-        mRotateDialog.dismissDialog();
-    }
-
-    private void cancelHighResComputation() {
-        mCancelComputation = true;
-        synchronized (mWaitObject) {
-            mWaitObject.notify();
-        }
-    }
-
-    @OnClickAttr
-    public void onCancelButtonClicked(View v) {
-        if (mPausing || mSurfaceTexture == null) return;
-        cancelHighResComputation();
-    }
-
-    @OnClickAttr
-    public void onThumbnailClicked(View v) {
-        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
-        showSharePopup();
-    }
-
-    private void showSharePopup() {
-        if (mThumbnail == null) return;
-        Uri uri = mThumbnail.getUri();
-        if (mSharePopup == null || !uri.equals(mSharePopup.getUri())) {
-            // The orientation compensation is set to 0 here because we only support landscape.
-            mSharePopup = new SharePopup(this, uri, mThumbnail.getBitmap(),
-                    mOrientationCompensation,
-                    findViewById(R.id.frame_layout));
-        }
-        mSharePopup.showAtLocation(mThumbnailView, Gravity.NO_GRAVITY, 0, 0);
-    }
-
-    private void reset() {
-        mCaptureState = CAPTURE_STATE_VIEWFINDER;
-
-        mReviewLayout.setVisibility(View.GONE);
-        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
-        mPanoProgressBar.setVisibility(View.GONE);
-        mCaptureLayout.setVisibility(View.VISIBLE);
-        mMosaicFrameProcessor.reset();
-
-        mSurfaceTexture.setOnFrameAvailableListener(this);
-    }
-
-    private void resetToPreview() {
-        reset();
-        if (!mPausing) {
-           mMosaicView.onPause();
-           mMosaicView.onResume();
-           startCameraPreview();
-        }
-    }
-
-    private void showFinalMosaic(Bitmap bitmap) {
-        if (bitmap != null) {
-            mReview.setImageBitmap(bitmap);
-        }
-        mCaptureLayout.setVisibility(View.GONE);
-        mReviewLayout.setVisibility(View.VISIBLE);
-    }
-
-    private Uri savePanorama(byte[] jpegData, int width, int height, int orientation) {
-        if (jpegData != null) {
-            String filename = PanoUtil.createName(
-                    getResources().getString(R.string.pano_file_name_format), mTimeTaken);
-            Uri uri = Storage.addImage(getContentResolver(), filename, mTimeTaken, null,
-                    orientation, jpegData, width, height);
-            if (uri != null && orientation != 0) {
-                String filepath = Storage.generateFilepath(filename);
-                try {
-                    // Save the orientation in EXIF.
-                    ExifInterface exif = new ExifInterface(filepath);
-                    exif.setAttribute(ExifInterface.TAG_ORIENTATION,
-                            getExifOrientation(orientation));
-                    exif.saveAttributes();
-                } catch (IOException e) {
-                    Log.e(TAG, "cannot set exif data: " + filepath);
-                }
-            }
-            return uri;
-        }
-        return null;
-    }
-
-    private static String getExifOrientation(int orientation) {
-        switch (orientation) {
-            case 0:
-                return String.valueOf(ExifInterface.ORIENTATION_NORMAL);
-            case 90:
-                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_90);
-            case 180:
-                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_180);
-            case 270:
-                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_270);
-            default:
-                throw new AssertionError("invalid: " + orientation);
-        }
-    }
-
-    private void clearMosaicFrameProcessorIfNeeded() {
-        if (!mPausing || mThreadRunning) return;
-        mMosaicFrameProcessor.clear();
-    }
-
-    private void initMosaicFrameProcessorIfNeeded() {
-        if (mPausing || mThreadRunning) return;
-        if (mMosaicFrameProcessor == null) {
-            // Start the activity for the first time.
-            mMosaicFrameProcessor = new MosaicFrameProcessor(
-                    mPreviewWidth, mPreviewHeight, getPreviewBufSize());
-        }
-        mMosaicFrameProcessor.initialize();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-
-        mPausing = true;
-        // Stop the capturing first.
-        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
-            stopCapture(true);
-            reset();
-        }
-        if (mSharePopup != null) mSharePopup.dismiss();
-
-        saveThumbnailToFile();
-
-        releaseCamera();
-        mMosaicView.onPause();
-        clearMosaicFrameProcessorIfNeeded();
-        mOrientationEventListener.disable();
-        resetScreenOn();
-        mCameraSound.release();
-        System.gc();
-    }
-
-    @Override
-    protected void doOnResume() {
-        mPausing = false;
-        mOrientationEventListener.enable();
-
-        mCaptureState = CAPTURE_STATE_VIEWFINDER;
-        try {
-            setupCamera();
-
-            // Camera must be initialized before MosaicFrameProcessor is initialized.
-            // The preview size has to be decided by camera device.
-            initMosaicFrameProcessorIfNeeded();
-            mMosaicView.onResume();
-
-            initThumbnailButton();
-            keepScreenOnAwhile();
-        } catch (CameraHardwareException e) {
-            Util.showErrorAndFinish(this, R.string.cannot_connect_camera);
-            return;
-        } catch (CameraDisabledException e) {
-            Util.showErrorAndFinish(this, R.string.camera_disabled);
-            return;
-        }
-        // Dismiss open menu if exists.
-        PopupManager.getInstance(this).notifyShowPopup(null);
-    }
-
-    /**
-     * Generate the final mosaic image.
-     *
-     * @param highRes flag to indicate whether we want to get a high-res version.
-     * @return a MosaicJpeg with its isValid flag set to true if successful; null if the generation
-     *         process is cancelled; and a MosaicJpeg with its isValid flag set to false if there
-     *         is an error in generating the final mosaic.
-     */
-    public MosaicJpeg generateFinalMosaic(boolean highRes) {
-        int mosaicReturnCode = mMosaicFrameProcessor.createMosaic(highRes);
-        if (mosaicReturnCode == Mosaic.MOSAIC_RET_CANCELLED) {
-            return null;
-        } else if (mosaicReturnCode == Mosaic.MOSAIC_RET_ERROR) {
-            return new MosaicJpeg();
-        }
-
-        byte[] imageData = mMosaicFrameProcessor.getFinalMosaicNV21();
-        if (imageData == null) {
-            Log.e(TAG, "getFinalMosaicNV21() returned null.");
-            return new MosaicJpeg();
-        }
-
-        int len = imageData.length - 8;
-        int width = (imageData[len + 0] << 24) + ((imageData[len + 1] & 0xFF) << 16)
-                + ((imageData[len + 2] & 0xFF) << 8) + (imageData[len + 3] & 0xFF);
-        int height = (imageData[len + 4] << 24) + ((imageData[len + 5] & 0xFF) << 16)
-                + ((imageData[len + 6] & 0xFF) << 8) + (imageData[len + 7] & 0xFF);
-        Log.v(TAG, "ImLength = " + (len) + ", W = " + width + ", H = " + height);
-
-        if (width <= 0 || height <= 0) {
-            // TODO: pop up a error meesage indicating that the final result is not generated.
-            Log.e(TAG, "width|height <= 0!!, len = " + (len) + ", W = " + width + ", H = " +
-                    height);
-            return new MosaicJpeg();
-        }
-
-        YuvImage yuvimage = new YuvImage(imageData, ImageFormat.NV21, width, height, null);
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        yuvimage.compressToJpeg(new Rect(0, 0, width, height), 100, out);
-        try {
-            out.close();
-        } catch (Exception e) {
-            Log.e(TAG, "Exception in storing final mosaic", e);
-            return new MosaicJpeg();
-        }
-        return new MosaicJpeg(out.toByteArray(), width, height);
-    }
-
-    private void setPreviewTexture(SurfaceTexture surface) {
-        try {
-            mCameraDevice.setPreviewTexture(surface);
-        } catch (Throwable ex) {
-            releaseCamera();
-            throw new RuntimeException("setPreviewTexture failed", ex);
-        }
-    }
-
-    private void startCameraPreview() {
-        // If we're previewing already, stop the preview first (this will blank
-        // the screen).
-        if (mCameraState != PREVIEW_STOPPED) stopCameraPreview();
-
-        // Set the display orientation to 0, so that the underlying mosaic library
-        // can always get undistorted mPreviewWidth x mPreviewHeight image data
-        // from SurfaceTexture.
-        mCameraDevice.setDisplayOrientation(0);
-
-        setPreviewTexture(mSurfaceTexture);
-
-        try {
-            Log.v(TAG, "startPreview");
-            mCameraDevice.startPreview();
-        } catch (Throwable ex) {
-            releaseCamera();
-            throw new RuntimeException("startPreview failed", ex);
-        }
-        mCameraState = PREVIEW_ACTIVE;
-    }
-
-    private void stopCameraPreview() {
-        if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
-            Log.v(TAG, "stopPreview");
-            mCameraDevice.stopPreview();
-        }
-        mCameraState = PREVIEW_STOPPED;
-    }
-
-    @Override
-    public void onUserInteraction() {
-        super.onUserInteraction();
-        if (mCaptureState != CAPTURE_STATE_MOSAIC) keepScreenOnAwhile();
-    }
-
-    @Override
-    public void onBackPressed() {
-        // If panorama is generating low res or high res mosaic, ignore back
-        // key. So the activity will not be destroyed.
-        if (mThreadRunning) return;
-        super.onBackPressed();
-    }
-
-    private void resetScreenOn() {
-        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
-        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-    }
-
-    private void keepScreenOnAwhile() {
-        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        mMainHandler.sendEmptyMessageDelayed(MSG_CLEAR_SCREEN_DELAY, SCREEN_DELAY);
-    }
-
-    private void keepScreenOn() {
-        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-    }
-}
-- 
1.7.9.5
